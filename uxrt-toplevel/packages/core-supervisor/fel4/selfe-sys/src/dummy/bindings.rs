/* automatically generated by rust-bindgen */

pub const CONFIG_ARM_HIKEY_OUTSTANDING_PREFETCHERS: u32 = 0;
pub const CONFIG_ARM_HIKEY_PREFETCHER_STRIDE: u32 = 0;
pub const CONFIG_ARM_HIKEY_PREFETCHER_NPFSTRM: u32 = 0;
pub const CONFIG_ARCH_X86_64: u32 = 1;
pub const CONFIG_ARCH_X86: u32 = 1;
pub const CONFIG_WORD_SIZE: u32 = 64;
pub const CONFIG_PC99_TSC_FREQUENCY: u32 = 0;
pub const CONFIG_USER_TOP: u32 = 2684354560;
pub const CONFIG_PLAT_PC99: u32 = 1;
pub const CONFIG_KERNEL_MCS: u32 = 1;
pub const CONFIG_ARCH_X86_NEHALEM: u32 = 1;
pub const CONFIG_IRQ_IOAPIC: u32 = 1;
pub const CONFIG_MAX_NUM_IOAPIC: u32 = 1;
pub const CONFIG_XAPIC: u32 = 1;
pub const CONFIG_CACHE_LN_SZ: u32 = 64;
pub const CONFIG_MAX_RMRR_ENTRIES: u32 = 1;
pub const CONFIG_MAX_VPIDS: u32 = 0;
pub const CONFIG_SYSCALL: u32 = 1;
pub const CONFIG_FXSAVE: u32 = 1;
pub const CONFIG_XSAVE_FEATURE_SET: u32 = 0;
pub const CONFIG_XSAVE_SIZE: u32 = 576;
pub const CONFIG_FSGSBASE_MSR: u32 = 1;
pub const CONFIG_MULTIBOOT_GRAPHICS_MODE_NONE: u32 = 1;
pub const CONFIG_MULTIBOOT1_HEADER: u32 = 1;
pub const CONFIG_MULTIBOOT2_HEADER: u32 = 1;
pub const CONFIG_KERNEL_SKIM_WINDOW: u32 = 1;
pub const CONFIG_KERNEL_X86_IBRS_NONE: u32 = 1;
pub const CONFIG_HAVE_FPU: u32 = 1;
pub const CONFIG_PADDR_USER_DEVICE_TOP: u64 = 140737488355328;
pub const CONFIG_ROOT_CNODE_SIZE_BITS: u32 = 15;
pub const CONFIG_BOOT_THREAD_TIME_SLICE: u32 = 5;
pub const CONFIG_RETYPE_FAN_OUT_LIMIT: u32 = 16384;
pub const CONFIG_MAX_NUM_WORK_UNITS_PER_PREEMPTION: u32 = 100;
pub const CONFIG_RESET_CHUNK_BITS: u32 = 8;
pub const CONFIG_MAX_NUM_BOOTINFO_UNTYPED_CAPS: u32 = 230;
pub const CONFIG_FASTPATH: u32 = 1;
pub const CONFIG_NUM_DOMAINS: u32 = 1;
pub const CONFIG_NUM_PRIORITIES: u32 = 256;
pub const CONFIG_MAX_NUM_NODES: u32 = 1;
pub const CONFIG_KERNEL_STACK_BITS: u32 = 12;
pub const CONFIG_FPU_MAX_RESTORES_SINCE_SWITCH: u32 = 64;
pub const CONFIG_DEBUG_BUILD: u32 = 1;
pub const CONFIG_HARDWARE_DEBUG_API: u32 = 1;
pub const CONFIG_PRINTING: u32 = 1;
pub const CONFIG_NO_BENCHMARKS: u32 = 1;
pub const CONFIG_MAX_NUM_TRACE_POINTS: u32 = 0;
pub const CONFIG_IRQ_REPORTING: u32 = 1;
pub const CONFIG_COLOUR_PRINTING: u32 = 1;
pub const CONFIG_USER_STACK_TRACE_LENGTH: u32 = 16;
pub const CONFIG_KERNEL_OPT_LEVEL_O2: u32 = 1;
pub const CONFIG_SET_TLS_BASE_SELF: u32 = 1;
pub const CONFIG_KERNEL_WCET_SCALE: u32 = 1;
pub const CONFIG_KERNEL_STATIC_MAX_PERIOD_US: u32 = 0;
pub const CONFIG_LIB_SEL4_PUBLIC_SYMBOLS: u32 = 1;
pub const CONFIG_LIB_SEL4_PRINT_INVOCATION_ERRORS: u32 = 0;
pub const seL4_True: u32 = 1;
pub const seL4_False: u32 = 0;
pub const TLS_GDT_ENTRY: u32 = 7;
pub const TLS_GDT_SELECTOR: u32 = 59;
pub const IPCBUF_GDT_ENTRY: u32 = 8;
pub const IPCBUF_GDT_SELECTOR: u32 = 67;
pub const seL4_DataFault: u32 = 0;
pub const seL4_InstructionFault: u32 = 1;
pub const seL4_WordSizeBits: u32 = 3;
pub const seL4_PageBits: u32 = 12;
pub const seL4_SlotBits: u32 = 5;
pub const seL4_TCBBits: u32 = 11;
pub const seL4_EndpointBits: u32 = 4;
pub const seL4_NotificationBits: u32 = 6;
pub const seL4_ReplyBits: u32 = 5;
pub const seL4_PageTableBits: u32 = 12;
pub const seL4_PageTableEntryBits: u32 = 3;
pub const seL4_PageTableIndexBits: u32 = 9;
pub const seL4_PageDirBits: u32 = 12;
pub const seL4_PageDirEntryBits: u32 = 3;
pub const seL4_PageDirIndexBits: u32 = 9;
pub const seL4_PDPTBits: u32 = 12;
pub const seL4_PDPTEntryBits: u32 = 3;
pub const seL4_PDPTIndexBits: u32 = 9;
pub const seL4_PML4Bits: u32 = 12;
pub const seL4_PML4EntryBits: u32 = 3;
pub const seL4_PML4IndexBits: u32 = 9;
pub const seL4_VSpaceBits: u32 = 12;
pub const seL4_IOPageTableBits: u32 = 12;
pub const seL4_LargePageBits: u32 = 21;
pub const seL4_HugePageBits: u32 = 30;
pub const seL4_NumASIDPoolsBits: u32 = 3;
pub const seL4_ASIDPoolBits: u32 = 12;
pub const seL4_ASIDPoolIndexBits: u32 = 9;
pub const seL4_MinUntypedBits: u32 = 4;
pub const seL4_MaxUntypedBits: u32 = 47;
pub const seL4_FastMessageRegisters: u32 = 4;
pub const seL4_IPCBufferSizeBits: u32 = 10;
pub const seL4_UserTop: u64 = 140737488351232;
pub const seL4_X64_HugePageObject: u32 = 4294967294;
pub const seL4_X86_IOPageTableObject: u32 = 16777215;
pub const seL4_X86_VCPUObject: u32 = 16777214;
pub const seL4_X86_EPTPML4Object: u32 = 16777213;
pub const seL4_X86_EPTPDPTObject: u32 = 16777212;
pub const seL4_X86_EPTPDObject: u32 = 16777211;
pub const seL4_X86_EPTPTObject: u32 = 16777210;
pub const seL4_CapRightsBits: u32 = 4;
pub const seL4_MinSchedContextBits: u32 = 8;
pub const seL4_RefillSizeBytes: u32 = 16;
pub const seL4_GuardSizeBits: u32 = 6;
pub const seL4_GuardBits: u32 = 58;
pub const seL4_BadgeBits: u32 = 64;
pub const seL4_UntypedRetypeMaxObjects: u32 = 16384;
pub const seL4_NilData: u32 = 0;
pub const IRQ_OFFSET: u32 = 48;
pub const VECTOR_MIN: u32 = 0;
pub const VECTOR_MAX: u32 = 109;
pub const MSI_MIN: u32 = 0;
pub const MSI_MAX: u32 = 109;
pub const seL4_VCPUBits: u32 = 14;
pub const seL4_X86_VCPUBits: u32 = 14;
pub const seL4_X86_EPTPML4EntryBits: u32 = 3;
pub const seL4_X86_EPTPML4IndexBits: u32 = 9;
pub const seL4_X86_EPTPML4Bits: u32 = 12;
pub const seL4_X86_EPTPDPTEntryBits: u32 = 3;
pub const seL4_X86_EPTPDPTIndexBits: u32 = 9;
pub const seL4_X86_EPTPDPTBits: u32 = 12;
pub const seL4_X86_EPTPDEntryBits: u32 = 3;
pub const seL4_X86_EPTPDIndexBits: u32 = 9;
pub const seL4_X86_EPTPDBits: u32 = 12;
pub const seL4_X86_EPTPTEntryBits: u32 = 3;
pub const seL4_X86_EPTPTIndexBits: u32 = 9;
pub const seL4_X86_EPTPTBits: u32 = 12;
pub const seL4_NumHWBreakpoints: u32 = 4;
pub const seL4_FirstBreakpoint: i32 = -1;
pub const seL4_NumExclusiveBreakpoints: u32 = 0;
pub const seL4_FirstWatchpoint: i32 = -1;
pub const seL4_NumExclusiveWatchpoints: u32 = 0;
pub const seL4_FirstDualFunctionMonitor: u32 = 0;
pub const seL4_NumDualFunctionMonitors: u32 = 4;
pub const CONFIG_SELFE_ROOT_STACK: u32 = 65536;
pub const CONFIG_SELFE_STATIC_TLS: u32 = 16384;
pub type seL4_Int8 = i8;
pub type seL4_Uint8 = u8;
pub type seL4_Int16 = i16;
pub type seL4_Uint16 = u16;
pub type seL4_Int32 = i32;
pub type seL4_Uint32 = u32;
pub type seL4_Int64 = i64;
pub type seL4_Uint64 = u64;
pub type seL4_Bool = seL4_Int8;
pub type seL4_Word = usize;
pub type seL4_CPtr = seL4_Word;
pub const seL4_VMFault_IP: seL4_VMFault_Msg = 0;
pub const seL4_VMFault_Addr: seL4_VMFault_Msg = 1;
pub const seL4_VMFault_PrefetchFault: seL4_VMFault_Msg = 2;
pub const seL4_VMFault_FSR: seL4_VMFault_Msg = 3;
pub const seL4_VMFault_Length: seL4_VMFault_Msg = 4;
pub const _enum_pad_seL4_VMFault_Msg: seL4_VMFault_Msg = 9223372036854775807;
pub type seL4_VMFault_Msg = u64;
pub const seL4_UnknownSyscall_RAX: seL4_UnknownSyscall_Msg = 0;
pub const seL4_UnknownSyscall_RBX: seL4_UnknownSyscall_Msg = 1;
pub const seL4_UnknownSyscall_RCX: seL4_UnknownSyscall_Msg = 2;
pub const seL4_UnknownSyscall_RDX: seL4_UnknownSyscall_Msg = 3;
pub const seL4_UnknownSyscall_RSI: seL4_UnknownSyscall_Msg = 4;
pub const seL4_UnknownSyscall_RDI: seL4_UnknownSyscall_Msg = 5;
pub const seL4_UnknownSyscall_RBP: seL4_UnknownSyscall_Msg = 6;
pub const seL4_UnknownSyscall_R8: seL4_UnknownSyscall_Msg = 7;
pub const seL4_UnknownSyscall_R9: seL4_UnknownSyscall_Msg = 8;
pub const seL4_UnknownSyscall_R10: seL4_UnknownSyscall_Msg = 9;
pub const seL4_UnknownSyscall_R11: seL4_UnknownSyscall_Msg = 10;
pub const seL4_UnknownSyscall_R12: seL4_UnknownSyscall_Msg = 11;
pub const seL4_UnknownSyscall_R13: seL4_UnknownSyscall_Msg = 12;
pub const seL4_UnknownSyscall_R14: seL4_UnknownSyscall_Msg = 13;
pub const seL4_UnknownSyscall_R15: seL4_UnknownSyscall_Msg = 14;
pub const seL4_UnknownSyscall_FaultIP: seL4_UnknownSyscall_Msg = 15;
pub const seL4_UnknownSyscall_SP: seL4_UnknownSyscall_Msg = 16;
pub const seL4_UnknownSyscall_FLAGS: seL4_UnknownSyscall_Msg = 17;
pub const seL4_UnknownSyscall_Syscall: seL4_UnknownSyscall_Msg = 18;
pub const seL4_UnknownSyscall_Length: seL4_UnknownSyscall_Msg = 19;
pub const _enum_pad_seL4_UnknownSyscall_Msg: seL4_UnknownSyscall_Msg = 9223372036854775807;
pub type seL4_UnknownSyscall_Msg = u64;
pub const seL4_UserException_FaultIP: seL4_UserException_Msg = 0;
pub const seL4_UserException_SP: seL4_UserException_Msg = 1;
pub const seL4_UserException_FLAGS: seL4_UserException_Msg = 2;
pub const seL4_UserException_Number: seL4_UserException_Msg = 3;
pub const seL4_UserException_Code: seL4_UserException_Msg = 4;
pub const seL4_UserException_Length: seL4_UserException_Msg = 5;
pub const _enum_pad_seL4_UserException_Msg: seL4_UserException_Msg = 9223372036854775807;
pub type seL4_UserException_Msg = u64;
pub const seL4_Timeout_Data: seL4_TimeoutMsg = 0;
pub const seL4_Timeout_Consumed: seL4_TimeoutMsg = 1;
pub const seL4_Timeout_Length: seL4_TimeoutMsg = 2;
pub const _enum_pad_seL4_Timeout_Msg: seL4_TimeoutMsg = 9223372036854775807;
pub type seL4_TimeoutMsg = u64;
pub const seL4_TimeoutReply_FaultIP: seL4_TimeoutReply_Msg = 0;
pub const seL4_TimeoutReply_RSP: seL4_TimeoutReply_Msg = 1;
pub const seL4_TimeoutReply_FLAGS: seL4_TimeoutReply_Msg = 2;
pub const seL4_TimeoutReply_RAX: seL4_TimeoutReply_Msg = 3;
pub const seL4_TimeoutReply_RBX: seL4_TimeoutReply_Msg = 4;
pub const seL4_TimeoutReply_RCX: seL4_TimeoutReply_Msg = 5;
pub const seL4_TimeoutReply_RDX: seL4_TimeoutReply_Msg = 6;
pub const seL4_TimeoutReply_RSI: seL4_TimeoutReply_Msg = 7;
pub const seL4_TimeoutReply_RDI: seL4_TimeoutReply_Msg = 8;
pub const seL4_TimeoutReply_RBP: seL4_TimeoutReply_Msg = 9;
pub const seL4_TimeoutReply_R8: seL4_TimeoutReply_Msg = 10;
pub const seL4_TimeoutReply_R9: seL4_TimeoutReply_Msg = 11;
pub const seL4_TimeoutReply_R10: seL4_TimeoutReply_Msg = 12;
pub const seL4_TimeoutReply_R11: seL4_TimeoutReply_Msg = 13;
pub const seL4_TimeoutReply_R12: seL4_TimeoutReply_Msg = 14;
pub const seL4_TimeoutReply_R13: seL4_TimeoutReply_Msg = 15;
pub const seL4_TimeoutReply_R14: seL4_TimeoutReply_Msg = 16;
pub const seL4_TimeoutReply_R15: seL4_TimeoutReply_Msg = 17;
pub const seL4_TimeoutReply_TLS_BASE: seL4_TimeoutReply_Msg = 18;
pub const seL4_TimeoutReply_Length: seL4_TimeoutReply_Msg = 19;
pub const _enum_pad_seL4_TimeoutReply_Msg: seL4_TimeoutReply_Msg = 9223372036854775807;
pub type seL4_TimeoutReply_Msg = u64;
pub type seL4_X64_PML4 = seL4_CPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_UserContext_ {
    pub rip: seL4_Word,
    pub rsp: seL4_Word,
    pub rflags: seL4_Word,
    pub rax: seL4_Word,
    pub rbx: seL4_Word,
    pub rcx: seL4_Word,
    pub rdx: seL4_Word,
    pub rsi: seL4_Word,
    pub rdi: seL4_Word,
    pub rbp: seL4_Word,
    pub r8: seL4_Word,
    pub r9: seL4_Word,
    pub r10: seL4_Word,
    pub r11: seL4_Word,
    pub r12: seL4_Word,
    pub r13: seL4_Word,
    pub r14: seL4_Word,
    pub r15: seL4_Word,
    pub fs_base: seL4_Word,
    pub gs_base: seL4_Word,
}
pub type seL4_UserContext = seL4_UserContext_;
pub type seL4_X86_ASIDControl = seL4_CPtr;
pub type seL4_X86_ASIDPool = seL4_CPtr;
pub type seL4_X86_IOSpace = seL4_CPtr;
pub type seL4_X86_IOPort = seL4_CPtr;
pub type seL4_X86_IOPortControl = seL4_CPtr;
pub type seL4_X86_Page = seL4_CPtr;
pub type seL4_X86_PDPT = seL4_CPtr;
pub type seL4_X86_PageDirectory = seL4_CPtr;
pub type seL4_X86_PageTable = seL4_CPtr;
pub type seL4_X86_IOPageTable = seL4_CPtr;
pub type seL4_X86_EPTPML4 = seL4_CPtr;
pub type seL4_X86_EPTPDPT = seL4_CPtr;
pub type seL4_X86_EPTPD = seL4_CPtr;
pub type seL4_X86_EPTPT = seL4_CPtr;
pub type seL4_X86_VCPU = seL4_CPtr;
pub const seL4_X86_Default_VMAttributes: seL4_X86_VMAttributes = 0;
pub const seL4_X86_WriteBack: seL4_X86_VMAttributes = 0;
pub const seL4_X86_WriteThrough: seL4_X86_VMAttributes = 1;
pub const seL4_X86_CacheDisabled: seL4_X86_VMAttributes = 2;
pub const seL4_X86_Uncacheable: seL4_X86_VMAttributes = 3;
pub const seL4_X86_WriteCombining: seL4_X86_VMAttributes = 4;
pub const _enum_pad_seL4_X86_VMAttributes: seL4_X86_VMAttributes = 9223372036854775807;
pub type seL4_X86_VMAttributes = u64;
pub const seL4_X86_EPT_Uncached_VMAttributes: seL4_X86_EPT_VMAttributes = 6;
pub const seL4_X86_EPT_Uncacheable: seL4_X86_EPT_VMAttributes = 0;
pub const seL4_X86_EPT_WriteCombining: seL4_X86_EPT_VMAttributes = 1;
pub const seL4_X86_EPT_WriteThrough: seL4_X86_EPT_VMAttributes = 4;
pub const seL4_X86_EPT_WriteProtected: seL4_X86_EPT_VMAttributes = 5;
pub const seL4_X86_EPT_WriteBack: seL4_X86_EPT_VMAttributes = 6;
pub const seL4_X86_EPT_Default_VMAttributes: seL4_X86_EPT_VMAttributes = 6;
pub const _enum_pad_seL4_X86_EPT_VMAttributes: seL4_X86_EPT_VMAttributes = 9223372036854775807;
pub type seL4_X86_EPT_VMAttributes = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_VCPUContext_ {
    pub eax: seL4_Word,
    pub ebx: seL4_Word,
    pub ecx: seL4_Word,
    pub edx: seL4_Word,
    pub esi: seL4_Word,
    pub edi: seL4_Word,
    pub ebp: seL4_Word,
}
pub type seL4_VCPUContext = seL4_VCPUContext_;
#[doc = " Hidden function, use the macros seL4_Fail or seL4_Assert."]
pub unsafe extern "C" fn __assert_fail(
    str: *const c_types::c_char,
    file: *const c_types::c_char,
    line: c_types::c_int,
    function: *const c_types::c_char,
){
    unimplemented!()
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_Fault {
    pub words: [seL4_Uint64; 20usize],
}
pub type seL4_Fault_t = seL4_Fault;
pub const seL4_Fault_NullFault: seL4_Fault_tag = 0;
pub const seL4_Fault_CapFault: seL4_Fault_tag = 1;
pub const seL4_Fault_UnknownSyscall: seL4_Fault_tag = 2;
pub const seL4_Fault_UserException: seL4_Fault_tag = 3;
pub const seL4_Fault_DebugException: seL4_Fault_tag = 4;
pub const seL4_Fault_Timeout: seL4_Fault_tag = 5;
pub const seL4_Fault_VMFault: seL4_Fault_tag = 6;
pub type seL4_Fault_tag = u32;
pub use self::seL4_Fault_tag as seL4_Fault_tag_t;
pub unsafe extern "C" fn seL4_Fault_get_seL4_FaultType(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_seL4_FaultType_equals(
    seL4_Fault: seL4_Fault_t,
    seL4_Fault_type_tag: seL4_Uint64,
) -> c_types::c_int{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_ptr_get_seL4_FaultType(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_NullFault_new() -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_NullFault_ptr_new(seL4_Fault_ptr: *mut seL4_Fault_t){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_new(
    IP: seL4_Uint64,
    Addr: seL4_Uint64,
    InRecvPhase: seL4_Uint64,
    LookupFailureType: seL4_Uint64,
    MR4: seL4_Uint64,
    MR5: seL4_Uint64,
    MR6: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_new(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    IP: seL4_Uint64,
    Addr: seL4_Uint64,
    InRecvPhase: seL4_Uint64,
    LookupFailureType: seL4_Uint64,
    MR4: seL4_Uint64,
    MR5: seL4_Uint64,
    MR6: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_IP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_IP(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_IP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_IP(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_Addr(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_Addr(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64)
    -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_Addr(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_Addr(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_InRecvPhase(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_InRecvPhase(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_InRecvPhase(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_InRecvPhase(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_LookupFailureType(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_LookupFailureType(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_LookupFailureType(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_LookupFailureType(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_MR4(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_MR4(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_MR4(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_MR4(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_MR5(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_MR5(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_MR5(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_MR5(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_get_MR6(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_set_MR6(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_get_MR6(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_CapFault_ptr_set_MR6(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_new(
    RAX: seL4_Uint64,
    RBX: seL4_Uint64,
    RCX: seL4_Uint64,
    RDX: seL4_Uint64,
    RSI: seL4_Uint64,
    RDI: seL4_Uint64,
    RBP: seL4_Uint64,
    R8: seL4_Uint64,
    R9: seL4_Uint64,
    R10: seL4_Uint64,
    R11: seL4_Uint64,
    R12: seL4_Uint64,
    R13: seL4_Uint64,
    R14: seL4_Uint64,
    R15: seL4_Uint64,
    FaultIP: seL4_Uint64,
    RSP: seL4_Uint64,
    FLAGS: seL4_Uint64,
    Syscall: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_new(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    RAX: seL4_Uint64,
    RBX: seL4_Uint64,
    RCX: seL4_Uint64,
    RDX: seL4_Uint64,
    RSI: seL4_Uint64,
    RDI: seL4_Uint64,
    RBP: seL4_Uint64,
    R8: seL4_Uint64,
    R9: seL4_Uint64,
    R10: seL4_Uint64,
    R11: seL4_Uint64,
    R12: seL4_Uint64,
    R13: seL4_Uint64,
    R14: seL4_Uint64,
    R15: seL4_Uint64,
    FaultIP: seL4_Uint64,
    RSP: seL4_Uint64,
    FLAGS: seL4_Uint64,
    Syscall: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RAX(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RAX(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RAX(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RAX(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RBX(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RBX(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RBX(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RBX(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RCX(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RCX(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RCX(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RCX(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RDX(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RDX(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RDX(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RDX(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RSI(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RSI(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RSI(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RSI(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RDI(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RDI(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RDI(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RDI(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RBP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RBP(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RBP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RBP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R8(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R8(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R8(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R8(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R9(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R9(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R9(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R9(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R10(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R10(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R10(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R10(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R11(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R11(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R11(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R11(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R12(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R12(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R12(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R12(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R13(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R13(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R13(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R13(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R14(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R14(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R14(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R14(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_R15(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_R15(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_R15(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_R15(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_FaultIP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_FaultIP(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_FaultIP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_FaultIP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_RSP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_RSP(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_RSP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_RSP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_FLAGS(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_FLAGS(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_FLAGS(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_FLAGS(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_get_Syscall(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_set_Syscall(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_get_Syscall(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UnknownSyscall_ptr_set_Syscall(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_new(
    FaultIP: seL4_Uint64,
    Stack: seL4_Uint64,
    FLAGS: seL4_Uint64,
    Number: seL4_Uint64,
    Code: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_new(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    FaultIP: seL4_Uint64,
    Stack: seL4_Uint64,
    FLAGS: seL4_Uint64,
    Number: seL4_Uint64,
    Code: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_get_FaultIP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_set_FaultIP(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_get_FaultIP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_set_FaultIP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_get_Stack(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_set_Stack(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_get_Stack(seL4_Fault_ptr: *mut seL4_Fault_t)
    -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_set_Stack(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_get_FLAGS(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_set_FLAGS(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_get_FLAGS(seL4_Fault_ptr: *mut seL4_Fault_t)
    -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_set_FLAGS(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_get_Number(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_set_Number(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_get_Number(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_set_Number(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_get_Code(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_set_Code(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_get_Code(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_UserException_ptr_set_Code(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_new(
    FaultIP: seL4_Uint64,
    ExceptionReason: seL4_Uint64,
    TriggerAddress: seL4_Uint64,
    BreakpointNumber: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_new(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    FaultIP: seL4_Uint64,
    ExceptionReason: seL4_Uint64,
    TriggerAddress: seL4_Uint64,
    BreakpointNumber: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_get_FaultIP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_set_FaultIP(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_get_FaultIP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_set_FaultIP(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_get_ExceptionReason(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_set_ExceptionReason(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_get_ExceptionReason(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_set_ExceptionReason(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_get_TriggerAddress(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_set_TriggerAddress(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_get_TriggerAddress(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_set_TriggerAddress(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_get_BreakpointNumber(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_set_BreakpointNumber(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_get_BreakpointNumber(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_DebugException_ptr_set_BreakpointNumber(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_new(data: seL4_Uint64, consumed: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_ptr_new(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    data: seL4_Uint64,
    consumed: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_get_data(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_set_data(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_ptr_get_data(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_ptr_set_data(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_get_consumed(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_set_consumed(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_ptr_get_consumed(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_Timeout_ptr_set_consumed(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_new(
    IP: seL4_Uint64,
    Addr: seL4_Uint64,
    PrefetchFault: seL4_Uint64,
    FSR: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_new(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    IP: seL4_Uint64,
    Addr: seL4_Uint64,
    PrefetchFault: seL4_Uint64,
    FSR: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_get_IP(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_set_IP(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_get_IP(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_set_IP(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_get_Addr(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_set_Addr(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_get_Addr(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_set_Addr(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_get_PrefetchFault(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_set_PrefetchFault(
    seL4_Fault: seL4_Fault_t,
    v64: seL4_Uint64,
) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_get_PrefetchFault(
    seL4_Fault_ptr: *mut seL4_Fault_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_set_PrefetchFault(
    seL4_Fault_ptr: *mut seL4_Fault_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_get_FSR(seL4_Fault: seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_set_FSR(seL4_Fault: seL4_Fault_t, v64: seL4_Uint64) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_get_FSR(seL4_Fault_ptr: *mut seL4_Fault_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_Fault_VMFault_ptr_set_FSR(seL4_Fault_ptr: *mut seL4_Fault_t, v64: seL4_Uint64){
    unimplemented!()
}
pub const seL4_SysCall: seL4_Syscall_ID = -1;
pub const seL4_SysReplyRecv: seL4_Syscall_ID = -2;
pub const seL4_SysNBSendRecv: seL4_Syscall_ID = -3;
pub const seL4_SysNBSendWait: seL4_Syscall_ID = -4;
pub const seL4_SysSend: seL4_Syscall_ID = -5;
pub const seL4_SysNBSend: seL4_Syscall_ID = -6;
pub const seL4_SysRecv: seL4_Syscall_ID = -7;
pub const seL4_SysNBRecv: seL4_Syscall_ID = -8;
pub const seL4_SysWait: seL4_Syscall_ID = -9;
pub const seL4_SysNBWait: seL4_Syscall_ID = -10;
pub const seL4_SysYield: seL4_Syscall_ID = -11;
pub const seL4_SysDebugPutChar: seL4_Syscall_ID = -12;
pub const seL4_SysDebugDumpScheduler: seL4_Syscall_ID = -13;
pub const seL4_SysDebugHalt: seL4_Syscall_ID = -14;
pub const seL4_SysDebugCapIdentify: seL4_Syscall_ID = -15;
pub const seL4_SysDebugSnapshot: seL4_Syscall_ID = -16;
pub const seL4_SysDebugNameThread: seL4_Syscall_ID = -17;
pub const seL4_SysSetTLSBase: seL4_Syscall_ID = -32;
pub const _enum_pad_seL4_Syscall_ID: seL4_Syscall_ID = 9223372036854775807;
pub type seL4_Syscall_ID = i64;
pub const seL4_UntypedObject: api_object = 0;
pub const seL4_TCBObject: api_object = 1;
pub const seL4_EndpointObject: api_object = 2;
pub const seL4_NotificationObject: api_object = 3;
pub const seL4_CapTableObject: api_object = 4;
pub const seL4_SchedContextObject: api_object = 5;
pub const seL4_ReplyObject: api_object = 6;
pub const seL4_NonArchObjectTypeCount: api_object = 7;
pub type api_object = u32;
pub use self::api_object as seL4_ObjectType;
pub type api_object_t = seL4_Word;
pub const seL4_X86_PDPTObject: _mode_object = 7;
pub const seL4_X64_PML4Object: _mode_object = 8;
pub const seL4_ModeObjectTypeCount: _mode_object = 9;
pub type _mode_object = u32;
pub use self::_mode_object as seL4_seL4ArchObjectType;
pub const seL4_X86_4K: _object = 9;
pub const seL4_X86_LargePageObject: _object = 10;
pub const seL4_X86_PageTableObject: _object = 11;
pub const seL4_X86_PageDirectoryObject: _object = 12;
pub const seL4_ObjectTypeCount: _object = 13;
pub type _object = u32;
pub use self::_object as seL4_ArchObjectType;
pub type object_t = seL4_Word;
pub const seL4_NoError: seL4_Error = 0;
pub const seL4_InvalidArgument: seL4_Error = 1;
pub const seL4_InvalidCapability: seL4_Error = 2;
pub const seL4_IllegalOperation: seL4_Error = 3;
pub const seL4_RangeError: seL4_Error = 4;
pub const seL4_AlignmentError: seL4_Error = 5;
pub const seL4_FailedLookup: seL4_Error = 6;
pub const seL4_TruncatedMessage: seL4_Error = 7;
pub const seL4_DeleteFirst: seL4_Error = 8;
pub const seL4_RevokeFirst: seL4_Error = 9;
pub const seL4_NotEnoughMemory: seL4_Error = 10;
pub const seL4_NumErrors: seL4_Error = 11;
pub type seL4_Error = u32;
pub const seL4_DataBreakpoint: seL4_BreakpointType = 0;
pub const seL4_InstructionBreakpoint: seL4_BreakpointType = 1;
pub const seL4_SingleStep: seL4_BreakpointType = 2;
pub const seL4_SoftwareBreakRequest: seL4_BreakpointType = 3;
pub const _enum_pad_seL4_BreakpointType: seL4_BreakpointType = 9223372036854775807;
pub type seL4_BreakpointType = u64;
pub const seL4_BreakOnRead: seL4_BreakpointAccess = 0;
pub const seL4_BreakOnWrite: seL4_BreakpointAccess = 1;
pub const seL4_BreakOnReadWrite: seL4_BreakpointAccess = 2;
pub const seL4_MaxBreakpointAccess: seL4_BreakpointAccess = 3;
pub const _enum_pad_seL4_BreakpointAccess: seL4_BreakpointAccess = 9223372036854775807;
pub type seL4_BreakpointAccess = u64;
pub const seL4_DebugException_FaultIP: seL4_DebugException_Msg = 0;
pub const seL4_DebugException_ExceptionReason: seL4_DebugException_Msg = 1;
pub const seL4_DebugException_TriggerAddress: seL4_DebugException_Msg = 2;
pub const seL4_DebugException_BreakpointNumber: seL4_DebugException_Msg = 3;
pub const seL4_DebugException_Length: seL4_DebugException_Msg = 4;
pub const _enum_pad_seL4_DebugException_Msg: seL4_DebugException_Msg = 9223372036854775807;
pub type seL4_DebugException_Msg = u64;
pub const seL4_InvalidPrio: priorityConstants = -1;
pub const seL4_MinPrio: priorityConstants = 0;
pub const seL4_MaxPrio: priorityConstants = 255;
pub type priorityConstants = i32;
pub const seL4_MsgLengthBits: seL4_MsgLimits = 7;
pub const seL4_MsgExtraCapBits: seL4_MsgLimits = 2;
pub type seL4_MsgLimits = u32;
pub const seL4_MsgMaxLength: _bindgen_ty_1 = 120;
pub type _bindgen_ty_1 = u32;
pub const seL4_NoFailure: seL4_LookupFailureType = 0;
pub const seL4_InvalidRoot: seL4_LookupFailureType = 1;
pub const seL4_MissingCapability: seL4_LookupFailureType = 2;
pub const seL4_DepthMismatch: seL4_LookupFailureType = 3;
pub const seL4_GuardMismatch: seL4_LookupFailureType = 4;
pub const _enum_pad_seL4_LookupFailureType: seL4_LookupFailureType = 9223372036854775807;
pub type seL4_LookupFailureType = u64;
pub const seL4_SchedContext_NoFlag: seL4_SchedContextFlag = 0;
pub const seL4_SchedContext_Sporadic: seL4_SchedContextFlag = 1;
pub const _enum_pad_seL4_SchedContextFlag: seL4_SchedContextFlag = 9223372036854775807;
pub type seL4_SchedContextFlag = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_CNode_CapData {
    pub words: [seL4_Uint64; 1usize],
}
pub type seL4_CNode_CapData_t = seL4_CNode_CapData;
pub unsafe extern "C" fn seL4_CNode_CapData_new(
    guard: seL4_Uint64,
    guardSize: seL4_Uint64,
) -> seL4_CNode_CapData_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_ptr_new(
    seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
    guard: seL4_Uint64,
    guardSize: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_get_guard(seL4_CNode_CapData: seL4_CNode_CapData_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_set_guard(
    seL4_CNode_CapData: seL4_CNode_CapData_t,
    v64: seL4_Uint64,
) -> seL4_CNode_CapData_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_ptr_get_guard(
    seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_ptr_set_guard(
    seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_get_guardSize(
    seL4_CNode_CapData: seL4_CNode_CapData_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_set_guardSize(
    seL4_CNode_CapData: seL4_CNode_CapData_t,
    v64: seL4_Uint64,
) -> seL4_CNode_CapData_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_ptr_get_guardSize(
    seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CNode_CapData_ptr_set_guardSize(
    seL4_CNode_CapData_ptr: *mut seL4_CNode_CapData_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_CapRights {
    pub words: [seL4_Uint64; 1usize],
}
pub type seL4_CapRights_t = seL4_CapRights;
pub unsafe extern "C" fn seL4_CapRights_new(
    capAllowGrantReply: seL4_Uint64,
    capAllowGrant: seL4_Uint64,
    capAllowRead: seL4_Uint64,
    capAllowWrite: seL4_Uint64,
) -> seL4_CapRights_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_new(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
    capAllowGrantReply: seL4_Uint64,
    capAllowGrant: seL4_Uint64,
    capAllowRead: seL4_Uint64,
    capAllowWrite: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_get_capAllowGrantReply(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_set_capAllowGrantReply(
    seL4_CapRights: seL4_CapRights_t,
    v64: seL4_Uint64,
) -> seL4_CapRights_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_get_capAllowGrantReply(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_set_capAllowGrantReply(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_get_capAllowGrant(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_set_capAllowGrant(
    seL4_CapRights: seL4_CapRights_t,
    v64: seL4_Uint64,
) -> seL4_CapRights_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_get_capAllowGrant(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_set_capAllowGrant(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_get_capAllowRead(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_set_capAllowRead(
    seL4_CapRights: seL4_CapRights_t,
    v64: seL4_Uint64,
) -> seL4_CapRights_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_get_capAllowRead(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_set_capAllowRead(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_get_capAllowWrite(seL4_CapRights: seL4_CapRights_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_set_capAllowWrite(
    seL4_CapRights: seL4_CapRights_t,
    v64: seL4_Uint64,
) -> seL4_CapRights_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_get_capAllowWrite(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CapRights_ptr_set_capAllowWrite(
    seL4_CapRights_ptr: *mut seL4_CapRights_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_MessageInfo {
    pub words: [seL4_Uint64; 1usize],
}
pub type seL4_MessageInfo_t = seL4_MessageInfo;
pub unsafe extern "C" fn seL4_MessageInfo_new(
    label: seL4_Uint64,
    capsUnwrapped: seL4_Uint64,
    extraCaps: seL4_Uint64,
    length: seL4_Uint64,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_new(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    label: seL4_Uint64,
    capsUnwrapped: seL4_Uint64,
    extraCaps: seL4_Uint64,
    length: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_get_label(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_set_label(
    seL4_MessageInfo: seL4_MessageInfo_t,
    v64: seL4_Uint64,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_get_label(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_set_label(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_get_capsUnwrapped(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_set_capsUnwrapped(
    seL4_MessageInfo: seL4_MessageInfo_t,
    v64: seL4_Uint64,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_get_capsUnwrapped(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_set_capsUnwrapped(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_get_extraCaps(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_set_extraCaps(
    seL4_MessageInfo: seL4_MessageInfo_t,
    v64: seL4_Uint64,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_get_extraCaps(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_set_extraCaps(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_get_length(seL4_MessageInfo: seL4_MessageInfo_t) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_set_length(
    seL4_MessageInfo: seL4_MessageInfo_t,
    v64: seL4_Uint64,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_get_length(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
) -> seL4_Uint64{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_MessageInfo_ptr_set_length(
    seL4_MessageInfo_ptr: *mut seL4_MessageInfo_t,
    v64: seL4_Uint64,
){
    unimplemented!()
}
#[repr(C)]
pub struct seL4_IPCBuffer_ {
    pub tag: seL4_MessageInfo_t,
    pub msg: [seL4_Word; 120usize],
    pub userData: seL4_Word,
    pub caps_or_badges: [seL4_Word; 3usize],
    pub receiveCNode: seL4_CPtr,
    pub receiveIndex: seL4_CPtr,
    pub receiveDepth: seL4_Word,
}
pub type seL4_IPCBuffer = seL4_IPCBuffer_;
pub const seL4_CapFault_IP: seL4_CapFault_Msg = 0;
pub const seL4_CapFault_Addr: seL4_CapFault_Msg = 1;
pub const seL4_CapFault_InRecvPhase: seL4_CapFault_Msg = 2;
pub const seL4_CapFault_LookupFailureType: seL4_CapFault_Msg = 3;
pub const seL4_CapFault_BitsLeft: seL4_CapFault_Msg = 4;
pub const seL4_CapFault_DepthMismatch_BitsFound: seL4_CapFault_Msg = 5;
pub const seL4_CapFault_GuardMismatch_GuardFound: seL4_CapFault_Msg = 5;
pub const seL4_CapFault_GuardMismatch_BitsFound: seL4_CapFault_Msg = 6;
pub const _enum_pad_seL4_CapFault_Msg: seL4_CapFault_Msg = 9223372036854775807;
pub type seL4_CapFault_Msg = u64;
pub type seL4_NodeId = seL4_Word;
pub type seL4_PAddr = seL4_Word;
pub type seL4_Domain = seL4_Word;
pub type seL4_CNode = seL4_CPtr;
pub type seL4_IRQHandler = seL4_CPtr;
pub type seL4_IRQControl = seL4_CPtr;
pub type seL4_TCB = seL4_CPtr;
pub type seL4_Untyped = seL4_CPtr;
pub type seL4_DomainSet = seL4_CPtr;
pub type seL4_SchedContext = seL4_CPtr;
pub type seL4_SchedControl = seL4_CPtr;
pub type seL4_Time = seL4_Uint64;
#[doc = " @xmlonly <manual name=\"Send\" label=\"sel4_mcs_send\"/> @endxmlonly"]
#[doc = " @brief Send to a capability"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_send\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] dest The capability to be invoked."]
#[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
pub unsafe extern "C" fn seL4_Send(dest: seL4_CPtr, msgInfo: seL4_MessageInfo_t){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Recv\" label=\"sel4_mcs_recv\"/> @endxmlonly"]
#[doc = " @brief Block until a message is received on an endpoint"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_recv\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] src The capability to be invoked."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
#[doc = " @param[in] reply The capability to the reply object to use on a call (only used on MCS)."]
#[doc = ""]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_Recv(
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Call\" label=\"sel4_mcs_call\"/> @endxmlonly"]
#[doc = " @brief  Call a capability"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_call\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] dest The capability to be invoked."]
#[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
#[doc = ""]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_Call(dest: seL4_CPtr, msgInfo: seL4_MessageInfo_t) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Non-Blocking Send\" label=\"sel4_mcs_nbsend\"/> @endxmlonly"]
#[doc = " @brief Perform a non-blocking send to a capability"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_nbsend\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] dest The capability to be invoked."]
#[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
pub unsafe extern "C" fn seL4_NBSend(dest: seL4_CPtr, msgInfo: seL4_MessageInfo_t){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Reply Recv\" label=\"sel4_mcs_replyrecv\"/> @endxmlonly"]
#[doc = " @brief Perform a reply followed by a receive in one system call"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_replyrecv\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] src The capability to perform the receive on."]
#[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
#[doc = ""]
#[doc = " @param[in] reply The capability to the reply object, which is first invoked and then used"]
#[doc = "                  for the recv phase to store a new reply capability."]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_ReplyRecv(
    src: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    sender: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"NBRecv\" label=\"sel4_mcs_nbrecv\"/> @endxmlonly"]
#[doc = " @brief Receive a message from an endpoint but do not block"]
#[doc = "        in the case that no messages are pending"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_nbrecv\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] src The capability to receive on."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "                    The sender information is the badge of the"]
#[doc = "                    endpoint capability that was invoked by the"]
#[doc = "                    sender, or the notification word of the"]
#[doc = "                    notification object that was signalled."]
#[doc = "                    This parameter is ignored if `NULL`."]
#[doc = " @param[in] reply The capability to the reply object to use on a call."]
#[doc = ""]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_NBRecv(
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"NBSend Recv\" label=\"sel4_nbsendrecv\"/> @endxmlonly"]
#[doc = " @brief Non-blocking send on one capability, and a blocking recieve on another in a single"]
#[doc = "        system call."]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_nbsendrecv\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] dest The capability to be invoked."]
#[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
#[doc = " @param[in] src The capability to receive on."]
#[doc = " @param[in] reply The capability to the reply object, which is first invoked and then used"]
#[doc = "                  for the recv phase to store a new reply capability."]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " as described in <autoref label=\"sec:messageinfo\"/>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_NBSendRecv(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"NBSend Wait\" label=\"sel4_nbsendwait\"/> @endxmlonly"]
#[doc = " @brief Non-blocking invoke of a capability and wait on another in one system call"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_nbsendwait\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] dest The capability to be invoked."]
#[doc = " @param[in] msgInfo The messageinfo structure for the IPC."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
#[doc = " @param[in] src The capability to receive on."]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " as described in <autoref label=\"sec:messageinfo\"/>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_NBSendWait(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    src: seL4_CPtr,
    sender: *mut seL4_Word,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Yield\" label=\"sel4_mcs_yield\"/> @endxmlonly"]
#[doc = " @brief Yield the remaining timeslice. Periodic threads will not be scheduled again until their"]
#[doc = "        next sporadic replenishment."]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sys_yield\"/></docref>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_Yield(){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Wait\" label=\"sel4_mcs_wait\"/> @endxmlonly"]
#[doc = " @brief Perform a wait on an endpoint or notification object"]
#[doc = ""]
#[doc = " Block on a notification or endpoint waiting for a message. No reply object is"]
#[doc = " required for a Wait. Wait should not be paired with Call, as it does not provide"]
#[doc = " a reply object. If Wait is paired with a Call the waiter will block after recieving"]
#[doc = " the message."]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See the description of <nameref name=\"seL4_Wait\"/> in <autoref label=\"sec:sys_wait\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] src The capability to be invoked."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
pub unsafe extern "C" fn seL4_Wait(src: seL4_CPtr, sender: *mut seL4_Word) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"NBWait\" label=\"sel4_nbwait\"/> @endxmlonly"]
#[doc = " @brief Perform a polling wait on an endpoint or notification object"]
#[doc = ""]
#[doc = " Poll a notification or endpoint waiting for a message. No reply object is"]
#[doc = " required for a Wait. Wait should not be paired with Call."]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See the description of <nameref name=\"seL4_NBWait\"/> in <autoref label=\"sec:sys_nbwait\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] src The capability to be invoked."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
pub unsafe extern "C" fn seL4_NBWait(src: seL4_CPtr, sender: *mut seL4_Word) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Poll\" label=\"sel4_mcs_poll\"/> @endxmlonly"]
#[doc = " @brief Perform a non-blocking recv on a notification object"]
#[doc = ""]
#[doc = " This is not a proper system call known by the kernel. Rather, it is a"]
#[doc = " convenience wrapper which calls seL4_NBWait()."]
#[doc = " It is useful for doing a non-blocking wait on a notification."]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See the description of <nameref name=\"seL4_NBWait\"/> in <autoref label=\"sec:sys_nbwait\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] src The capability to be invoked."]
#[doc = " @param[out] sender The address to write sender information to."]
#[doc = "               The sender information is the badge of the"]
#[doc = "               endpoint capability that was invoked by the"]
#[doc = "               sender, or the notification word of the"]
#[doc = "               notification object that was signalled."]
#[doc = "               This parameter is ignored if `NULL`."]
#[doc = ""]
#[doc = " @return A `seL4_MessageInfo_t` structure"]
#[doc = " @xmlonly"]
#[doc = " <docref>as described in <autoref label=\"sec:messageinfo\"/></docref>"]
#[doc = " @endxmlonly"]
pub unsafe extern "C" fn seL4_Poll(src: seL4_CPtr, sender: *mut seL4_Word) -> seL4_MessageInfo_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Signal\" label=\"sel4_mcs_signal\"/> @endxmlonly"]
#[doc = " @brief Signal a notification"]
#[doc = ""]
#[doc = " This is not a proper system call known by the kernel. Rather, it is a"]
#[doc = " convenience wrapper which calls seL4_Send()."]
#[doc = " It is useful for signalling a notification."]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See the description of <nameref name=\"seL4_Send\"/> in <autoref label=\"sec:sys_send\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] dest The capability to be invoked."]
pub unsafe extern "C" fn seL4_Signal(dest: seL4_CPtr){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Put Char\" label=\"sel4_debugputchar\"/> @endxmlonly"]
#[doc = " @brief Output a single char through the kernel."]
#[doc = ""]
#[doc = " Use the kernel serial driver to output a single character. This is useful for"]
#[doc = " debugging when a user level serial driver is not available."]
#[doc = ""]
#[doc = " @param c The character to output."]
#[doc = ""]
pub unsafe extern "C" fn seL4_DebugPutChar(c: c_types::c_char){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Dump scheduler\" label=\"sel4_dumpscheduler\"/> @endxmlonly"]
#[doc = " @brief Output the contents of the kernel scheduler."]
#[doc = ""]
#[doc = " Dump the state of the all TCB objects to kernel serial output. This system call"]
#[doc = " will output a table containing:"]
#[doc = "    - Address: the address of the TCB object for that thread,"]
#[doc = "    - Name:    the name of the thread (if set),"]
#[doc = "    - IP:      the contents of the instruction pointer the thread is at,"]
#[doc = "    - Priority: the priority of that thread,"]
#[doc = "    - State   : the state of the thread."]
pub unsafe extern "C" fn seL4_DebugDumpScheduler(){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Halt\" label=\"sel4_debughalt\"/> @endxmlonly"]
#[doc = " @brief Halt the system."]
#[doc = ""]
#[doc = " This debugging system call will cause the kernel immediately cease responding to"]
#[doc = " system calls. The kernel will switch permanently to the idle thread with"]
#[doc = " interrupts disabled. Depending on the platform, the kernel may switch"]
#[doc = " the hardware into a low-power state."]
#[doc = ""]
pub unsafe extern "C" fn seL4_DebugHalt(){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Snapshot\" label=\"sel4_debugsnapshot\"/> @endxmlonly"]
#[doc = " @brief Output a capDL dump of the current kernel state."]
#[doc = ""]
#[doc = " This debugging system call will output all of the capabilities in the current"]
#[doc = " kernel using capDL."]
#[doc = ""]
pub unsafe extern "C" fn seL4_DebugSnapshot(){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Cap Identify\" label=\"sel4_debugcapidentify\"/> @endxmlonly"]
#[doc = " @brief Identify the type of a capability in the current cspace."]
#[doc = ""]
#[doc = " This debugging system call returns the type of capability in a capability"]
#[doc = " slot in the current cspace. The type returned is not a libsel4 type, but"]
#[doc = " refers to an internal seL4 type. This can be looked up in a built kernel by"]
#[doc = " looking for the (generated) `enum cap_tag`, type `cap_tag_t`."]
#[doc = ""]
#[doc = " @param cap A capability slot in the current cspace."]
#[doc = " @return The type of capability passed in."]
#[doc = ""]
pub unsafe extern "C" fn seL4_DebugCapIdentify(cap: seL4_CPtr) -> seL4_Uint32{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Name Thread\" label=\"sel4_debugnamethread\"/> @endxmlonly"]
#[doc = " @brief Name a thread."]
#[doc = ""]
#[doc = " Name a thread. This name will then be output by the kernel in all debugging output."]
#[doc = " Note that the max name length that can be passed to this function is limited by the"]
#[doc = " number of chars that will fit in an IPC message (`seL4_MsgMaxLength` multiplied by the"]
#[doc = " amount of chars that fit in a word). However the name is also truncated in order to fit into a TCB object."]
#[doc = " For some platforms you may need to increase `seL4_TCBBits` by 1 in a debug build in order to"]
#[doc = " fit a long enough name."]
#[doc = ""]
#[doc = " @param tcb A capability to the tcb object for the thread to name."]
#[doc = " @param name The name for the thread."]
#[doc = ""]
pub unsafe extern "C" fn seL4_DebugNameThread(tcb: seL4_CPtr, name: *const c_types::c_char){
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"SetTLSBase\" label=\"sel4_settlsbase\"/> @endxmlonly"]
#[doc = " @brief Set the TLS base address and register of the currently executing thread."]
#[doc = ""]
#[doc = " This stores the base address of the TLS region in the register"]
#[doc = " reserved for that purpose on the given platform."]
#[doc = ""]
#[doc = " Each platform has a specific register reserved for tracking the"]
#[doc = " base address of the TLS region (as sepcified in the ELF standard) in"]
#[doc = " a manner compatible with the TLS method used with that architecture."]
#[doc = ""]
#[doc = " @param tls_base The new base address to store in the register."]
pub unsafe extern "C" fn seL4_SetTLSBase(tls_base: seL4_Word){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_SetIPCBuffer(ipc_buffer: *mut seL4_IPCBuffer){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetIPCBuffer() -> *mut seL4_IPCBuffer{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetMR(i: c_types::c_int) -> seL4_Word{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_SetMR(i: c_types::c_int, mr: seL4_Word){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetUserData() -> seL4_Word{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_SetUserData(data: seL4_Word){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetBadge(i: c_types::c_int) -> seL4_Word{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetCap(i: c_types::c_int) -> seL4_CPtr{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_SetCap(i: c_types::c_int, cptr: seL4_CPtr){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetCapReceivePath(
    receiveCNode: *mut seL4_CPtr,
    receiveIndex: *mut seL4_CPtr,
    receiveDepth: *mut seL4_Word,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_SetCapReceivePath(
    receiveCNode: seL4_CPtr,
    receiveIndex: seL4_CPtr,
    receiveDepth: seL4_Word,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_SendWithMRs(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_NBSendWithMRs(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_RecvWithMRs(
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_WaitWithMRs(
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_CallWithMRs(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_ReplyRecvWithMRs(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    sender: *mut seL4_Word,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_NBSendRecvWithMRs(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
    reply: seL4_CPtr,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_NBSendWaitWithMRs(
    dest: seL4_CPtr,
    msgInfo: seL4_MessageInfo_t,
    src: seL4_CPtr,
    sender: *mut seL4_Word,
    mr0: *mut seL4_Word,
    mr1: *mut seL4_Word,
    mr2: *mut seL4_Word,
    mr3: *mut seL4_Word,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_DebugPutString(str: *mut c_types::c_char){
    unimplemented!()
}
pub unsafe extern "C" fn strcpy(arg1: *mut c_types::c_char, arg2: *const c_types::c_char)
    -> *mut c_types::c_char{
    unimplemented!()
}
pub const InvalidInvocation: invocation_label = 0;
pub const UntypedRetype: invocation_label = 1;
pub const TCBReadRegisters: invocation_label = 2;
pub const TCBWriteRegisters: invocation_label = 3;
pub const TCBCopyRegisters: invocation_label = 4;
pub const TCBConfigure: invocation_label = 5;
pub const TCBSetPriority: invocation_label = 6;
pub const TCBSetMCPriority: invocation_label = 7;
pub const TCBSetSchedParams: invocation_label = 8;
pub const TCBSetTimeoutEndpoint: invocation_label = 9;
pub const TCBSetIPCBuffer: invocation_label = 10;
pub const TCBSetSpace: invocation_label = 11;
pub const TCBSuspend: invocation_label = 12;
pub const TCBResume: invocation_label = 13;
pub const TCBBindNotification: invocation_label = 14;
pub const TCBUnbindNotification: invocation_label = 15;
pub const TCBSetBreakpoint: invocation_label = 16;
pub const TCBGetBreakpoint: invocation_label = 17;
pub const TCBUnsetBreakpoint: invocation_label = 18;
pub const TCBConfigureSingleStepping: invocation_label = 19;
pub const TCBSetTLSBase: invocation_label = 20;
pub const CNodeRevoke: invocation_label = 21;
pub const CNodeDelete: invocation_label = 22;
pub const CNodeCancelBadgedSends: invocation_label = 23;
pub const CNodeCopy: invocation_label = 24;
pub const CNodeMint: invocation_label = 25;
pub const CNodeMove: invocation_label = 26;
pub const CNodeMutate: invocation_label = 27;
pub const CNodeRotate: invocation_label = 28;
pub const IRQIssueIRQHandler: invocation_label = 29;
pub const IRQAckIRQ: invocation_label = 30;
pub const IRQSetIRQHandler: invocation_label = 31;
pub const IRQClearIRQHandler: invocation_label = 32;
pub const DomainSetSet: invocation_label = 33;
pub const SchedControlConfigureFlags: invocation_label = 34;
pub const SchedContextBind: invocation_label = 35;
pub const SchedContextUnbind: invocation_label = 36;
pub const SchedContextUnbindObject: invocation_label = 37;
pub const SchedContextConsumed: invocation_label = 38;
pub const SchedContextYieldTo: invocation_label = 39;
pub const nInvocationLabels: invocation_label = 40;
pub type invocation_label = u32;
pub const X86PDPTMap: sel4_arch_invocation_label = 40;
pub const X86PDPTUnmap: sel4_arch_invocation_label = 41;
pub const nSeL4ArchInvocationLabels: sel4_arch_invocation_label = 42;
pub type sel4_arch_invocation_label = u32;
pub const X86PageDirectoryMap: arch_invocation_label = 42;
pub const X86PageDirectoryUnmap: arch_invocation_label = 43;
pub const X86PageTableMap: arch_invocation_label = 44;
pub const X86PageTableUnmap: arch_invocation_label = 45;
pub const X86PageMap: arch_invocation_label = 46;
pub const X86PageUnmap: arch_invocation_label = 47;
pub const X86PageGetAddress: arch_invocation_label = 48;
pub const X86ASIDControlMakePool: arch_invocation_label = 49;
pub const X86ASIDPoolAssign: arch_invocation_label = 50;
pub const X86IOPortControlIssue: arch_invocation_label = 51;
pub const X86IOPortIn8: arch_invocation_label = 52;
pub const X86IOPortIn16: arch_invocation_label = 53;
pub const X86IOPortIn32: arch_invocation_label = 54;
pub const X86IOPortOut8: arch_invocation_label = 55;
pub const X86IOPortOut16: arch_invocation_label = 56;
pub const X86IOPortOut32: arch_invocation_label = 57;
pub const X86IRQIssueIRQHandlerIOAPIC: arch_invocation_label = 58;
pub const X86IRQIssueIRQHandlerMSI: arch_invocation_label = 59;
pub const nArchInvocationLabels: arch_invocation_label = 60;
pub type arch_invocation_label = u32;
pub type __type_int_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_long_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Uint8_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Uint16_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Uint32_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Uint64_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Time_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Word_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Bool_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_CapRights_t_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_CPtr_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_CNode_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_IRQHandler_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_IRQControl_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_TCB_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_Untyped_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_DomainSet_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_SchedContext_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_SchedControl_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_VMAttributes_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_IOPort_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_IOPortControl_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_ASIDControl_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_ASIDPool_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_IOSpace_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_Page_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X64_PML4_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_PDPT_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_PageDirectory_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_PageTable_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_IOPageTable_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_VCPU_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_EPTPML4_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_EPTPDPT_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_EPTPD_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_X86_EPTPT_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_VCPUContext_size_incorrect = [c_types::c_ulong; 1usize];
pub type __type_seL4_UserContext_size_incorrect = [c_types::c_ulong; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_PageDirectory_GetStatusBits {
    pub error: c_types::c_int,
    pub accessed: seL4_Word,
    pub dirty: seL4_Word,
}
pub type seL4_X86_PageDirectory_GetStatusBits_t = seL4_X86_PageDirectory_GetStatusBits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_Page_GetAddress {
    pub error: c_types::c_int,
    pub paddr: seL4_Word,
}
pub type seL4_X86_Page_GetAddress_t = seL4_X86_Page_GetAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_IOPort_In8 {
    pub error: c_types::c_int,
    pub result: seL4_Uint8,
}
pub type seL4_X86_IOPort_In8_t = seL4_X86_IOPort_In8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_IOPort_In16 {
    pub error: c_types::c_int,
    pub result: seL4_Uint16,
}
pub type seL4_X86_IOPort_In16_t = seL4_X86_IOPort_In16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_IOPort_In32 {
    pub error: c_types::c_int,
    pub result: seL4_Uint32,
}
pub type seL4_X86_IOPort_In32_t = seL4_X86_IOPort_In32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_VCPU_ReadVMCS {
    pub error: c_types::c_int,
    pub value: seL4_Word,
}
pub type seL4_X86_VCPU_ReadVMCS_t = seL4_X86_VCPU_ReadVMCS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_VCPU_WriteVMCS {
    pub error: c_types::c_int,
    pub written: seL4_Word,
}
pub type seL4_X86_VCPU_WriteVMCS_t = seL4_X86_VCPU_WriteVMCS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_TCB_GetBreakpoint {
    pub error: c_types::c_int,
    pub vaddr: seL4_Word,
    pub type_: seL4_Word,
    pub size: seL4_Word,
    pub rw: seL4_Word,
    pub is_enabled: seL4_Bool,
}
pub type seL4_TCB_GetBreakpoint_t = seL4_TCB_GetBreakpoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_TCB_ConfigureSingleStepping {
    pub error: c_types::c_int,
    pub bp_was_consumed: seL4_Bool,
}
pub type seL4_TCB_ConfigureSingleStepping_t = seL4_TCB_ConfigureSingleStepping;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_SchedContext_Consumed {
    pub error: c_types::c_int,
    pub consumed: seL4_Time,
}
pub type seL4_SchedContext_Consumed_t = seL4_SchedContext_Consumed;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_SchedContext_YieldTo {
    pub error: c_types::c_int,
    pub consumed: seL4_Time,
}
pub type seL4_SchedContext_YieldTo_t = seL4_SchedContext_YieldTo;
#[doc = " @xmlonly <manual name=\"Map\" label=\"x86_64_pdpt_map\"/> @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " TODO"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @param[in] pml4"]
#[doc = " @param[in] vaddr"]
#[doc = " @param[in] attr"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst A mapping already exists for this level in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"pml4\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"pml4\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"pml4\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a VSpace."]
pub unsafe extern "C" fn seL4_X86_PDPT_Map(
    _service: seL4_X86_PDPT,
    pml4: seL4_X64_PML4,
    vaddr: seL4_Word,
    attr: seL4_X86_VMAttributes,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unmap\" label=\"x86_64_pdpt_unmap\"/> @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " TODO"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RevokeFirst A copy of the  @xmlonly <texttt text=\"_service\"/> @endxmlonly  capability exists."]
pub unsafe extern "C" fn seL4_X86_PDPT_Unmap(_service: seL4_X86_PDPT) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Map\" label=\"x86_page_directory_map\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Map a page directory. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"ch:vspace\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page directory being operated on."]
#[doc = " @param[in] vspace Capability to the VSpace which will contain the mapping"]
#[doc = " @param[in] vaddr Virtual address to map the page into."]
#[doc = " @param[in] attr VM attributes for the mapping.  @xmlonly <docref>Possible values for this type are given in <autoref label=\"ch:vspace\"/></docref> @endxmlonly"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst A mapping already exists for this level in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  does not have a PDPT mapped at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a VSpace."]
pub unsafe extern "C" fn seL4_X86_PageDirectory_Map(
    _service: seL4_X86_PageDirectory,
    vspace: seL4_CPtr,
    vaddr: seL4_Word,
    attr: seL4_X86_VMAttributes,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unmap\" label=\"x86_page_directory_unmap\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Unmap a page directory. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"ch:vspace\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page directory being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RevokeFirst A copy of the  @xmlonly <texttt text=\"_service\"/> @endxmlonly  capability exists."]
pub unsafe extern "C" fn seL4_X86_PageDirectory_Unmap(_service: seL4_X86_PageDirectory) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Map\" label=\"x86_pagetable_map\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Map a page table into an address space. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Takes a <texttt text=\"PageDirectory\"/> capability as an argument,"]
#[doc = " and installs a reference to the invoked"]
#[doc = " <texttt text=\"PageTable\"/> in a specified slot in the <texttt text=\"PageDirectory\"/>."]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page table being operated on."]
#[doc = " @param[in] vspace Capability to the VSpace which will contain the mapping"]
#[doc = " @param[in] vaddr Virtual address to map the page into."]
#[doc = " @param[in] attr VM attributes for the mapping.  @xmlonly <docref>Possible values for this type are given in <autoref label=\"ch:vspace\"/></docref> @endxmlonly"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst A mapping already exists for this level in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  does not have a Page Directory mapped at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a VSpace."]
pub unsafe extern "C" fn seL4_X86_PageTable_Map(
    _service: seL4_X86_PageTable,
    vspace: seL4_CPtr,
    vaddr: seL4_Word,
    attr: seL4_X86_VMAttributes,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unmap\" label=\"x86_pagetable_unmap\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Unmap a page table from its address space and zero it out. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Removes the reference to the invoked <texttt text=\"PageTable\"/> from its containing"]
#[doc = " <texttt text=\"PageDirectory\"/>."]
#[doc = " <docref>See <autoref label=\"ch:vspace\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page table being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RevokeFirst A copy of the  @xmlonly <texttt text=\"_service\"/> @endxmlonly  capability exists."]
pub unsafe extern "C" fn seL4_X86_PageTable_Unmap(_service: seL4_X86_PageTable) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Map\" label=\"x86_page_map\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Map a page into an address space or update the mapping attributes. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Takes a VSpace capability, as an"]
#[doc = " argument and installs a reference"]
#[doc = " to the given <texttt text=\"Page\"/> in the lowest-level unmapped paging structure"]
#[doc = " corresponding to the given address, or updates the mapping attributes if the page is already mapped at this address. If the required paging structures are not present"]
#[doc = " this operation will fail, returning a seL4_FailedLookup error."]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page being operated on."]
#[doc = " @param[in] vspace Capability to the VSpace which will contain the mapping"]
#[doc = " @param[in] vaddr Virtual address to map the page into."]
#[doc = " @param[in] rights Rights for the mapping.  @xmlonly <docref>Possible values for this type are given in <autoref label=\"sec:cap_rights\"/></docref> @endxmlonly"]
#[doc = " @param[in] attr VM attributes for the mapping.  @xmlonly <docref>Possible values for this type are given in <autoref label=\"ch:vspace\"/></docref> @endxmlonly"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_AlignmentError The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is not aligned to the page size of  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
#[doc = " @retval seL4_DeleteFirst A mapping already exists in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  does not have a paging structure at the required level mapped at  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in an IOSpace."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  at a different virtual address."]
#[doc = " Or,  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is already mapped in a different VSpace."]
pub unsafe extern "C" fn seL4_X86_Page_Map(
    _service: seL4_X86_Page,
    vspace: seL4_CPtr,
    vaddr: seL4_Word,
    rights: seL4_CapRights_t,
    attr: seL4_X86_VMAttributes,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unmap\" label=\"x86_page_unmap\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Unmap a page. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Removes an existing mapping."]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_Page_Unmap(_service: seL4_X86_Page) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Get Address\" label=\"x86_page_getaddress\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Get the physical address of the underlying frame. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"ch:vspace\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the page being operated on."]
#[doc = " @return @xmlonly"]
#[doc = "                 A <texttt text=\"seL4_IA32_Page_GetAddress_t\"/> struct that contains a"]
#[doc = "                 <texttt text=\"seL4_Word paddr\"/>, which holds the physical address of the page,"]
#[doc = "                 and <texttt text=\"int error\"/>. <docref>See <autoref label=\"sec:errors\"/> for a description"]
#[doc = "                 of the message register and tag contents upon error.</docref>"]
#[doc = "              @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_Page_GetAddress(_service: seL4_X86_Page) -> seL4_X86_Page_GetAddress_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Make Pool\" label=\"x86_ASID_controlmakepool\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Create an X86 ASID pool. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Together with a capability to <texttt text=\"Untyped Memory\"/>, which is passed as an argument,"]
#[doc = " create an <texttt text=\"ASID Pool\"/>. The untyped capability must represent a"]
#[doc = " 4K memory object. This will create an ASID pool with enough space for 1024 VSpaces."]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service The master ASIDControl capability."]
#[doc = " @param[in] untyped Capability to an untyped memory object that will become the pool. Must be 4K bytes."]
#[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] depth Number of bits of index to resolve to find the destination slot."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " Or, there are no more ASID pools available."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  is not the exact size of an ASID pool object."]
#[doc = " Or,  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  is a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  has been used to retype an object."]
#[doc = " Or, a copy of the  @xmlonly <texttt text=\"untyped\"/> @endxmlonly  capability exists."]
pub unsafe extern "C" fn seL4_X86_ASIDControl_MakePool(
    _service: seL4_X86_ASIDControl,
    untyped: seL4_Untyped,
    root: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Assign\" label=\"x86_asidpool_assign\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Assign an ASID pool. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Assigns an ASID to the VSpace associated with the <texttt text=\"Page Directory\"/> passed in as an argument."]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service The ASID pool which is being assigned to. Must not be full. Each ASID pool can contain 1024 entries."]
#[doc = " @param[in] vspace The page directory that is being assigned to an ASID pool. Must not already be assigned to an ASID pool."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst There are no more ASIDs available in  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace\"/> @endxmlonly  is already assigned to an ASID pool."]
pub unsafe extern "C" fn seL4_X86_ASIDPool_Assign(_service: seL4_X86_ASIDPool, vspace: seL4_CPtr) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Issue\" label=\"x86_ioport_issue\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Issue an IO port sub range. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Control capability for I/O ports."]
#[doc = " @param[in] first_port First port of the range of the issued capability."]
#[doc = " @param[in] last_port Last port of the range of the issued capability."]
#[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace."]
#[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] depth Number of bits of dest_index to resolve to find the destination slot."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"last_port\"/> @endxmlonly  is less than  @xmlonly <texttt text=\"first_port\"/> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst One or more ports in the requested range have already been issued."]
pub unsafe extern "C" fn seL4_X86_IOPortControl_Issue(
    _service: seL4_X86_IOPortControl,
    first_port: seL4_Word,
    last_port: seL4_Word,
    root: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"In8\" label=\"x86_io_port_in8\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Read 8 bits from an IO port. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An I/O Port capability."]
#[doc = " @param[in] port The port to read from."]
#[doc = " @return @xmlonly"]
#[doc = "                 A <texttt text=\"seL4_X86_IOPort_In8_t\"/> structure <docref>as described in <autoref label=\"sec:ioports\"/>.</docref>"]
#[doc = "              @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, reading from  @xmlonly <texttt text=\"port\"/> @endxmlonly  is not authorized by the capability."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_IOPort_In8(
    _service: seL4_X86_IOPort,
    port: seL4_Uint16,
) -> seL4_X86_IOPort_In8_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"In16\" label=\"x86_io_port_in16\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Read 16 bits from an IO port. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An I/O Port capability."]
#[doc = " @param[in] port The port to read from."]
#[doc = " @return @xmlonly"]
#[doc = "                 A <texttt text=\"seL4_X86_IOPort_In16_t\"/> structure <docref>as described in <autoref label=\"sec:ioports\"/>.</docref>"]
#[doc = "              @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, reading from  @xmlonly <texttt text=\"port\"/> @endxmlonly  and  @xmlonly <texttt text=\"port+1\"/> @endxmlonly  is not authorized by the capability."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_IOPort_In16(
    _service: seL4_X86_IOPort,
    port: seL4_Uint16,
) -> seL4_X86_IOPort_In16_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"In32\" label=\"x86_io_port_in32\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Read 32 bits from an IO port. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An I/O Port capability."]
#[doc = " @param[in] port The port to read from."]
#[doc = " @return @xmlonly"]
#[doc = "                 A <texttt text=\"seL4_X86_IOPort_In32_t\"/> structure <docref>as described in <autoref label=\"sec:ioports\"/>.</docref>"]
#[doc = "              @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, reading from ports  @xmlonly <texttt text=\"port\"/> @endxmlonly  through  @xmlonly <texttt text=\"port+3\"/> @endxmlonly  is not authorized by the capability."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_IOPort_In32(
    _service: seL4_X86_IOPort,
    port: seL4_Uint16,
) -> seL4_X86_IOPort_In32_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Out8\" label=\"x86_io_port_out8\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Write 8 bits to an IO port. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An I/O Port capability."]
#[doc = " @param[in] port The port to write to."]
#[doc = " @param[in] data Data to write to the IO port."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, writing to  @xmlonly <texttt text=\"port\"/> @endxmlonly  is not authorized by the capability."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_IOPort_Out8(
    _service: seL4_X86_IOPort,
    port: seL4_Word,
    data: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Out16\" label=\"x86_io_port_out16\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Write 16 bits to an IO port. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An I/O Port capability."]
#[doc = " @param[in] port The port to write to."]
#[doc = " @param[in] data Data to write to the IO port."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, writing to  @xmlonly <texttt text=\"port\"/> @endxmlonly  and  @xmlonly <texttt text=\"port+1\"/> @endxmlonly  is not authorized by the capability."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_IOPort_Out16(
    _service: seL4_X86_IOPort,
    port: seL4_Word,
    data: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Out32\" label=\"x86_io_port_out32\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Write 32 bits to an IO port. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:ioports\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An I/O Port capability."]
#[doc = " @param[in] port The port to write to."]
#[doc = " @param[in] data Data to write to the IO port."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, writing to ports  @xmlonly <texttt text=\"port\"/> @endxmlonly  through  @xmlonly <texttt text=\"port+3\"/> @endxmlonly  is not authorized by the capability."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_X86_IOPort_Out32(
    _service: seL4_X86_IOPort,
    port: seL4_Word,
    data: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Get I/O APIC\" label=\"x86_irq_control_get_io_apic\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Create an IRQ handler capability for an interrupt from an IOAPIC. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:interrupts\"/> and <autoref label=\"sec:x86_interrupts\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An IRQControl capability. This gives you the authority to make this call."]
#[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] depth Number of bits of index to resolve to find the destination slot."]
#[doc = " @param[in] ioapic Zero based index of IOAPIC to get interrupt from,                              ordered the same as in ACPI tables"]
#[doc = " @param[in] pin IOAPIC pin that generates the interrupt."]
#[doc = " @param[in] level Indicates whether the IOAPIC should be programmed to treat this interrupt as level triggered."]
#[doc = " @param[in] polarity Indicates whether the IOAPIC should be programmed to treat this interrupt as high or                      low triggered"]
#[doc = " @param[in] vector CPU vector to deliver the interrupt to."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, an IOAPIC is not in use."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"vector\"/> @endxmlonly ,  @xmlonly <texttt text=\"ioapic\"/> @endxmlonly , or  @xmlonly <texttt text=\"pin\"/> @endxmlonly  is invalid."]
#[doc = " Or,  @xmlonly <texttt text=\"level\"/> @endxmlonly  or  @xmlonly <texttt text=\"polarity\"/> @endxmlonly  is not 0 or 1."]
#[doc = " Or,  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst An IRQ handler capability for  @xmlonly <texttt text=\"vector\"/> @endxmlonly  has already been created."]
pub unsafe extern "C" fn seL4_IRQControl_GetIOAPIC(
    _service: seL4_IRQControl,
    root: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
    ioapic: seL4_Word,
    pin: seL4_Word,
    level: seL4_Word,
    polarity: seL4_Word,
    vector: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Get MSI\" label=\"x86_irq_control_get_msi\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Create an IRQ handler capability for an interrupt from an MSI. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:interrupts\"/> and <autoref label=\"sec:x86_interrupts\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An IRQControl capability. This gives you the authority to make this call."]
#[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] depth Number of bits of index to resolve to find the destination slot."]
#[doc = " @param[in] pci_bus PCI bus ID of the device that will generate the interrupt."]
#[doc = " @param[in] pci_dev PCI device ID of the device that will generate the interrupt."]
#[doc = " @param[in] pci_func PCI function ID of the device that will generate the interrupt."]
#[doc = " @param[in] handle Value of the handle programmed into the data portion of the MSI."]
#[doc = " @param[in] vector CPU vector to deliver the interrupt to."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, an IOAPIC is not in use."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"vector\"/> @endxmlonly ,  @xmlonly <texttt text=\"pic_bus\"/> @endxmlonly ,  @xmlonly <texttt text=\"pci_dev\"/> @endxmlonly , or  @xmlonly <texttt text=\"pci_func\"/> @endxmlonly  is invalid."]
#[doc = " Or, the  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst An IRQ handler capability for  @xmlonly <texttt text=\"vector\"/> @endxmlonly  has already been created."]
pub unsafe extern "C" fn seL4_IRQControl_GetMSI(
    _service: seL4_IRQControl,
    root: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
    pci_bus: seL4_Word,
    pci_dev: seL4_Word,
    pci_func: seL4_Word,
    handle: seL4_Word,
    vector: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Retype\" label=\"untyped_retype\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Retype an untyped object @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Given a capability, <texttt text=\"_service\"/>, to an untyped object,"]
#[doc = " creates <texttt text=\"num_objects\"/> of the requested type. Creates"]
#[doc = " <texttt text=\"num_objects\"/> capabilities to the new objects starting"]
#[doc = " at <texttt text=\"node_offset\"/> in the CNode specified by"]
#[doc = " <texttt text=\"root\"/>, <texttt text=\"node_index\"/>, and"]
#[doc = " <texttt text=\"node_depth\"/>."]
#[doc = ""]
#[doc = " For variable-sized"]
#[doc = " kernel objects, the <texttt text=\"size_bits\"/> argument is used to"]
#[doc = " determine the size of objects to create. The relationship between"]
#[doc = " <texttt text=\"size_bits\"/> and object size depends on the type of object"]
#[doc = " being created. <docref>See <autoref label=\"sec:object_sizes\"/> for more information"]
#[doc = " about object sizes.</docref>"]
#[doc = ""]
#[doc = " <docref>See <autoref label=\"sec:kernmemalloc\"/> for more information about how untyped"]
#[doc = " memory is retyped.</docref>"]
#[doc = ""]
#[doc = " <docref>See <autoref label=\"sec:caps_to_new_objects\"/> for more information about the"]
#[doc = " placement of capabilities to created objects.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to an untyped object."]
#[doc = " @param[in] type The seL4 object type that we are retyping to."]
#[doc = " @param[in] size_bits Used to determine the size of variable-sized objects."]
#[doc = " @param[in] root CPTR to the CNode at the root of the destination CSpace."]
#[doc = " @param[in] node_index CPTR to the destination CNode. Resolved relative to the root parameter."]
#[doc = " @param[in] node_depth Number of bits of node_index to translate when addressing the destination CNode."]
#[doc = " @param[in] node_offset Number of slots into the node at which capabilities start being placed."]
#[doc = " @param[in] num_objects Number of capabilities to create."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst A capability exists in the destination window of the CNode."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"root\"/> @endxmlonly ,  @xmlonly <texttt text=\"node_index\"/> @endxmlonly , or  @xmlonly <texttt text=\"node_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"size_bits\"/> @endxmlonly  is too big or too small for the requested object type."]
#[doc = " Or,  @xmlonly <texttt text=\"type\"/> @endxmlonly  cannot be created from a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
#[doc = " Or, the requested object  @xmlonly <texttt text=\"type\"/> @endxmlonly  does not exist."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_NotEnoughMemory The total size of the new objects exceeds the space available."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"num_objects\"/> @endxmlonly  do not fit in the destination CNode at  @xmlonly <texttt text=\"node_offset\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"num_objects\"/> @endxmlonly  is greater than  @xmlonly <texttt text=\"CONFIG_RETYPE_FAN_OUT_LIMIT\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"size_bits\"/> @endxmlonly  is too large."]
pub unsafe extern "C" fn seL4_Untyped_Retype(
    _service: seL4_Untyped,
    type_: seL4_Word,
    size_bits: seL4_Word,
    root: seL4_CNode,
    node_index: seL4_Word,
    node_depth: seL4_Word,
    node_offset: seL4_Word,
    num_objects: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Read Registers\" label=\"tcb_readregisters\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Read a thread's registers into the first <texttt text=\"count\"/> fields of a given"]
#[doc = " seL4_UserContext @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:read_write_registers\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] suspend_source The invocation should also suspend the source thread."]
#[doc = " @param[in] arch_flags Architecture dependent flags. These have no mearing on either x86 or ARM."]
#[doc = " @param[in] count The number of registers to read."]
#[doc = " @param[out] regs The structure to read the registers into."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is the current thread's TCB."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"count\"/> @endxmlonly  requested too few or too many registers."]
pub unsafe extern "C" fn seL4_TCB_ReadRegisters(
    _service: seL4_TCB,
    suspend_source: seL4_Bool,
    arch_flags: seL4_Uint8,
    count: seL4_Word,
    regs: *mut seL4_UserContext,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Write Registers\" label=\"tcb_writeregisters\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set a thread's registers to the first <texttt text=\"count\"/> fields of a given seL4_UserContext @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:read_write_registers\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] resume_target The invocation should also resume the destination thread."]
#[doc = " @param[in] arch_flags Architecture dependent flags. These have no mearing on either x86 or ARM."]
#[doc = " @param[in] count The number of registers to be set."]
#[doc = " @param[in] regs Data structure containing the new register values."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is the current thread's TCB."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_WriteRegisters(
    _service: seL4_TCB,
    resume_target: seL4_Bool,
    arch_flags: seL4_Uint8,
    count: seL4_Word,
    regs: *mut seL4_UserContext,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Copy Registers\" label=\"tcb_copyregisters\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Copy the registers from one thread to another @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " In the context of this function, frame registers are those that are read, modified or preserved by a"]
#[doc = " system call and integer registers are those that are not. Refer to the seL4 userland library source for specifics."]
#[doc = " <docref><autoref label=\"sec:thread_deactivation\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on. This is the destination TCB."]
#[doc = " @param[in] source Cap to the source TCB."]
#[doc = " @param[in] suspend_source The invocation should also suspend the source thread."]
#[doc = " @param[in] resume_target The invocation should also resume the destination thread."]
#[doc = " @param[in] transfer_frame Frame registers should be transferred."]
#[doc = " @param[in] transfer_integer Integer registers should be transferred."]
#[doc = " @param[in] arch_flags Architecture dependent flags. These have no mearing on either x86 or ARM."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"source\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_CopyRegisters(
    _service: seL4_TCB,
    source: seL4_TCB,
    suspend_source: seL4_Bool,
    resume_target: seL4_Bool,
    transfer_frame: seL4_Bool,
    transfer_integer: seL4_Bool,
    arch_flags: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Configure (MCS)\" label=\"tcb_configure_mcs\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set the parameters of a TCB @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:threads\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] cspace_root The new CSpace root."]
#[doc = " @param[in] cspace_root_data Optionally set the guard and guard size of the new root CNode. If set to zero, this parameter has no effect."]
#[doc = " @param[in] vspace_root The new VSpace root."]
#[doc = " @param[in] vspace_root_data Has no effect on x86 or ARM processors."]
#[doc = " @param[in] buffer Location of the thread's IPC buffer. Must be 512-byte aligned. The IPC buffer may not cross a page boundary."]
#[doc = " @param[in] bufferFrame Capability to a page containing the thread's IPC buffer."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_AlignmentError The  @xmlonly <texttt text=\"buffer\"/> @endxmlonly  is not aligned."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly ,  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly ,  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly , or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " Or,  @xmlonly <texttt text=\"cspace_root_data\"/> @endxmlonly  is invalid."]
#[doc = " Or,  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is retyped from a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly ,  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly , or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_Configure(
    _service: seL4_TCB,
    cspace_root: seL4_CNode,
    cspace_root_data: seL4_Word,
    vspace_root: seL4_CPtr,
    vspace_root_data: seL4_Word,
    buffer: seL4_Word,
    bufferFrame: seL4_CPtr,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Priority\" label=\"tcb_setpriority\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Change a thread's priority @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sched\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] authority Capability to the TCB to use the MCP from when setting the priority."]
#[doc = " @param[in] priority The thread's new priority."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"authority\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"priority\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
pub unsafe extern "C" fn seL4_TCB_SetPriority(
    _service: seL4_TCB,
    authority: seL4_TCB,
    priority: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Maximum Controlled Priority\" label=\"tcb_setmcpriority\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Change a thread's maximum controlled priority @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sched\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] authority Capability to the TCB to use the MCP from when setting the MCP."]
#[doc = " @param[in] mcp The thread's new maximum controlled priority."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"authority\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"mcp\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
pub unsafe extern "C" fn seL4_TCB_SetMCPriority(
    _service: seL4_TCB,
    authority: seL4_TCB,
    mcp: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Sched Params (MCS)\" label=\"tcb_setschedparams_mcs\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Change a thread's priority, maximum controlled priority, scheduling context"]
#[doc = " and fault handler. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:sched\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] authority Capability to the TCB to use the MCP from when setting the priority and MCP."]
#[doc = " @param[in] mcp The thread's new maximum controlled priority."]
#[doc = " @param[in] priority The thread's new priority."]
#[doc = " @param[in] sched_context Capability to the scheduling context that the TCB should run on. If the scheduling context is already bound to a notification or TCB that is not this TCB this operation will fail. Similarly, if this TCB is already bound to a scheduling context that is not this scheduling context, this will also fail."]
#[doc = " @param[in] fault_ep CPTR to the endpoint which receives IPCs when this thread faults."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"sched_context\"/> @endxmlonly  is already bound."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is the current thread's TCB."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a TCB in the blocked state and  @xmlonly <texttt text=\"sched_context\"/> @endxmlonly  is not schedulable."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly ,  @xmlonly <texttt text=\"authority\"/> @endxmlonly ,  @xmlonly <texttt text=\"sched_context\"/> @endxmlonly , or  @xmlonly <texttt text=\"fault_ep\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"fault_ep\"/> @endxmlonly  does not have both Write rights and either Grant or GrantReply rights to the Endpoint  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"mcp\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"priority\"/> @endxmlonly  is greater than the maximum controlled priority of  @xmlonly <texttt text=\"authority\"/> @endxmlonly ."]
pub unsafe extern "C" fn seL4_TCB_SetSchedParams(
    _service: seL4_TCB,
    authority: seL4_TCB,
    mcp: seL4_Word,
    priority: seL4_Word,
    sched_context: seL4_CPtr,
    fault_ep: seL4_CPtr,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Timeout Endpoint\" label=\"tcb_settimeoutendpoint\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set a thread's timeout endpoint. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " Timeout exception messages will be delivered to this endpoint if it is not a null capability."]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] timeout_fault_ep CPTR to the endpoint which receives IPCs when this thread triggers timeout faults. Can be null."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"timeout_fault_ep\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"timeout_fault_ep\"/> @endxmlonly  does not have both Write rights and either Grant or GrantReply rights to the Endpoint  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_TCB_SetTimeoutEndpoint(
    _service: seL4_TCB,
    timeout_fault_ep: seL4_CPtr,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set IPC Buffer\" label=\"tcb_setipcbuffer\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set a thread's IPC buffer @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " See Sections <shortref sec=\"threads\"/> and <shortref sec=\"messageinfo\"/>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] buffer Location of the thread's IPC buffer. Must be 512-byte aligned. The IPC buffer may not cross a page boundary."]
#[doc = " @param[in] bufferFrame Capability to a page containing the thread's IPC buffer."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_AlignmentError The  @xmlonly <texttt text=\"buffer\"/> @endxmlonly  is not aligned."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is retyped from a device untyped  @xmlonly <docref>(see <autoref label=\"sec:kernmemalloc\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"bufferFrame\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_SetIPCBuffer(
    _service: seL4_TCB,
    buffer: seL4_Word,
    bufferFrame: seL4_CPtr,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Space\" label=\"tcb_setspace_mcs\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set the fault endpoint, CSpace and VSpace of a thread @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:threads\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] fault_ep CPTR to the endpoint which receives IPCs when this thread faults. On MCS this cap gets copied into the TCB."]
#[doc = " @param[in] cspace_root The new CSpace root."]
#[doc = " @param[in] cspace_root_data Optionally set the guard and guard size of the new root CNode. If set to zero, this parameter has no effect."]
#[doc = " @param[in] vspace_root The new VSpace root."]
#[doc = " @param[in] vspace_root_data Has no effect on x86 or ARM processors."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly ,  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly , or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is not assigned to an ASID pool."]
#[doc = " Or,  @xmlonly <texttt text=\"cspace_root_data\"/> @endxmlonly  is invalid."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"fault_ep\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"fault_ep\"/> @endxmlonly  does not have both Write rights and either Grant or GrantReply rights to the Endpoint  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst The  @xmlonly <texttt text=\"cspace_root\"/> @endxmlonly  or  @xmlonly <texttt text=\"vspace_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_SetSpace(
    _service: seL4_TCB,
    fault_ep: seL4_CPtr,
    cspace_root: seL4_CNode,
    cspace_root_data: seL4_Word,
    vspace_root: seL4_CPtr,
    vspace_root_data: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Suspend\" label=\"tcb_suspend\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Suspend a thread @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:thread_deactivation\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_Suspend(_service: seL4_TCB) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Resume\" label=\"tcb_resume\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Resume a thread @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:thread_deactivation\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_Resume(_service: seL4_TCB) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Bind Notification\" label=\"tcb_bindnotification\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Binds a notification object to a <obj name=\"TCB\"/> @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:notification-binding\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] notification Notification to bind."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"notification\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"notification\"/> @endxmlonly  is already bound."]
#[doc = " Or,  @xmlonly <texttt text=\"notification\"/> @endxmlonly  does not have Read rights to the Notification  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_BindNotification(_service: seL4_TCB, notification: seL4_CPtr) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unbind Notification\" label=\"tcb_unbindnotification\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Unbinds any notification object from a <obj name=\"TCB\"/> @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:notification-binding\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not bound to a notification."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_UnbindNotification(_service: seL4_TCB) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Breakpoint\" label=\"tcb_setbreakpoint\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set or modify a thread's breakpoints or watchpoints. Calls to this function"]
#[doc = " overwrite previous configurations for the target breakpoint. Do not use this"]
#[doc = " with seL4_SingleStep: the API will reject the call and return an error."]
#[doc = " Instead, use seL4_TCB_ConfigureSingleStepping to configure single-stepping. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:debug_exceptions\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] bp_num The API-ID of a target breakpoint. This ID will be a positive integer, with values ranging from 0 to seL4_NumHWBreakpoints - 1."]
#[doc = " @param[in] vaddr A virtual address which forms part of the match conditions for the triggering of the breakpoint."]
#[doc = " @param[in] type One of: seL4_InstructionBreakpoint, which specifies that the breakpoint should occur on instruction execution at the specified vaddr or seL4_DataBreakpoint, which states that the breakpoint should occur on data access at the specified vaddr."]
#[doc = " @param[in] size A positive integer indicating the trigger-span of the watchpoint. Must be zero when 'type' is seL4_InstructionBreakpoint."]
#[doc = " @param[in] rw One of seL4_BreakOnRead, meaning the breakpoint will only be triggered on read-access; seL4_BreakOnWrite meaning the breakpoint will only be triggered on write-access, and seL4_BreakOnReadWrite meaning the breakpoint will be triggered on any access."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_AlignmentError The  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is not aligned to  @xmlonly <texttt text=\"size\"/> @endxmlonly  bytes."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"bp_num\"/> @endxmlonly ,  @xmlonly <texttt text=\"size\"/> @endxmlonly , or  @xmlonly <texttt text=\"rw\"/> @endxmlonly  is not valid for the given  @xmlonly <texttt text=\"type\"/> @endxmlonly ."]
#[doc = " Or, argument values are inappropriate for the target architecture."]
#[doc = " Or,  @xmlonly <texttt text=\"vaddr\"/> @endxmlonly  is in the kernel virtual address range."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The argument values are inappropriate for the target architecture."]
pub unsafe extern "C" fn seL4_TCB_SetBreakpoint(
    _service: seL4_TCB,
    bp_num: seL4_Uint16,
    vaddr: seL4_Word,
    type_: seL4_Word,
    size: seL4_Word,
    rw: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Get Breakpoint\" label=\"tcb_getbreakpoint\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Read a breakpoint or watchpoint's current configuration. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:debug_exceptions\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] bp_num The API-ID of a target breakpoint. This ID will be a positive integer, with values ranging from 0 to seL4_NumHWBreakpoints - 1."]
#[doc = " @return @xmlonly"]
#[doc = "                 A <texttt text=\"seL4_TCB_GetBreakpoint_t\"/>: Struct that contains"]
#[doc = "                 <texttt text=\"seL4_Error error\"/>, an seL4 API error value,"]
#[doc = "                 <texttt text=\"seL4_Word vaddr\"/>, the virtual address at which the breakpoint will currently"]
#[doc = "                 be triggered;"]
#[doc = "                 <texttt text=\"seL4_Word type\"/>, the type of operation which will currently trigger the"]
#[doc = "                 breakpoint, whether instruction execution, or data access;"]
#[doc = "                 <texttt text=\"seL4_Word size\"/>, integer value for the span-size of the breakpoint."]
#[doc = "                 Usually a power of two (1, 2, 4, etc.);"]
#[doc = "                 <texttt text=\"seL4_Word rw\"/>, the access direction that will currently trigger the breakpoint,"]
#[doc = "                 whether read, write, or both and"]
#[doc = "                 <texttt text=\"seL4_Bool is_enabled\"/>, which indicates whether or not the breakpoint"]
#[doc = "                 will currently be triggered if the match conditions are met."]
#[doc = "              @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The argument values are inappropriate for the target architecture."]
pub unsafe extern "C" fn seL4_TCB_GetBreakpoint(
    _service: seL4_TCB,
    bp_num: seL4_Uint16,
) -> seL4_TCB_GetBreakpoint_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unset Breakpoint\" label=\"tcb_unsetbreakpoint\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Disables a hardware breakpoint or watchpoint. The caller should assume that"]
#[doc = " the underlying configuration of the hardware registers has also been cleared."]
#[doc = " Do not use this to clear single-stepping: the API will reject the call and"]
#[doc = " return an error. Instead, use seL4_TCB_ConfigureSingleStepping to disable"]
#[doc = " single-stepping. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:debug_exceptions\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] bp_num The API-ID of a target breakpoint. This ID will be a positive integer, with values ranging from 0 to seL4_NumHWBreakpoints - 1."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the argument values are inappropriate for the target architecture."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The argument values are inappropriate for the target architecture."]
pub unsafe extern "C" fn seL4_TCB_UnsetBreakpoint(_service: seL4_TCB, bp_num: seL4_Uint16) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Configure Single Stepping\" label=\"tcb_configuresinglestepping\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set or modify single stepping options for the target TCB. Subsequent calls to this"]
#[doc = " function overwrite previous configuration. Depending on your processor architecture,"]
#[doc = " this may or may not require the consumption of a hardware register. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See Sections <shortref sec=\"single_stepping_debug_exception\"/> and <shortref sec=\"debug_exceptions\"/></docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] bp_num The API-ID of a target breakpoint. This ID will be a positive integer, with values ranging from 0 to seL4_NumHWBreakpoints - 1."]
#[doc = " @param[in] num_instructions Number of instructions to step over before delivering a fault to the target thread's fault endpoint. Setting this to 0 disables single-stepping."]
#[doc = " @return @xmlonly"]
#[doc = "                 A <texttt text=\"seL4_TCB_ConfigureSingleStepping_t\"/>: Struct that contains"]
#[doc = "                 <texttt text=\"seL4_Error error\"/>, an seL4 API error value,"]
#[doc = "                 <texttt text=\"seL4_Bool bp_was_consumed\"/>, a boolean which indicates whether or not the <texttt text=\"bp_num\"/>"]
#[doc = "                 breakpoint ID that was passed to the function, was consumed in the setup of the single-stepping"]
#[doc = "                 functionality: if this is <texttt text=\"true\"/>, the caller should not attempt to re-use <texttt text=\"bp_num\"/>"]
#[doc = "                 until it has disabled the single-stepping functionality via a subsequent call to"]
#[doc = "                 seL4_TCB_ConfigureSingleStepping with an <texttt text=\"num_instructions\"/> argument of 0."]
#[doc = "              @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the argument values are inappropriate for the target architecture."]
#[doc = " @retval seL4_InvalidArgument The argument values are inappropriate for the target architecture."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_ConfigureSingleStepping(
    _service: seL4_TCB,
    bp_num: seL4_Uint16,
    num_instructions: seL4_Word,
) -> seL4_TCB_ConfigureSingleStepping_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set TLS Base\" label=\"tcb_settlsbase\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set the TLS base of the target TCB. This intended for use on architectures where the register"]
#[doc = " used for TLS can only be written to in privilidged mode @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = ""]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability to the TCB which is being operated on."]
#[doc = " @param[in] tls_base The TLS base to set"]
#[doc = " @return @xmlonly"]
#[doc = "               @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_TCB_SetTLSBase(_service: seL4_TCB, tls_base: seL4_Word) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Revoke\" label=\"cnode_revoke\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Delete all child capabilities of a capability @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability will be found. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the capability. Resolved from the root of the _service parameter."]
#[doc = " @param[in] depth Number of bits of index to resolve to find the capability being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Revoke(
    _service: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Delete\" label=\"cnode_delete\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Delete a capability @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability will be found. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the capability. Resolved from the root of the _service parameter."]
#[doc = " @param[in] depth Number of bits of index to resolve to find the capability being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Delete(
    _service: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Cancel Badged Sends\" label=\"cnode_cancelbadgedsends\"/> @endxmlonly"]
#[doc = " @brief @xmlonly The cancel badged sends method is intend to allow for the reuse of badges by an"]
#[doc = " authority. When used with a badged endpoint capability it"]
#[doc = " will cancel any outstanding send operations for that endpoint and badge."]
#[doc = " This operation has no effect on un-badged or other objects. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the capability will be found. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the capability. Resolved from the root of the _service parameter."]
#[doc = " @param[in] depth Number of bits of index to resolve to find the capability being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"index\"/> @endxmlonly  or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the capability does not have full rights to the Endpoint  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_CancelBadgedSends(
    _service: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Copy\" label=\"cnode_copy\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Copy a capability, setting its access rights whilst doing so @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
#[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
#[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
#[doc = " @param[in] rights The rights inherited by the new capability. @xmlonly <docref>Possible values for this type are given in <autoref label=\"sec:cap_rights\"/>  .</docref> @endxmlonly"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source slot is empty."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst The source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Copy(
    _service: seL4_CNode,
    dest_index: seL4_Word,
    dest_depth: seL4_Uint8,
    src_root: seL4_CNode,
    src_index: seL4_Word,
    src_depth: seL4_Uint8,
    rights: seL4_CapRights_t,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Mint\" label=\"cnode_mint\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Copy a capability, setting its access rights and badge whilst doing so @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
#[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
#[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
#[doc = " @param[in] rights The rights inherited by the new capability. @xmlonly <docref>Possible values for this type are given in <autoref label=\"sec:cap_rights\"/>  .</docref> @endxmlonly"]
#[doc = " @param[in] badge Badge or guard to be applied to the new capability. For badges on 32-bit platforms, the high 4 bits are ignored."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source slot is empty."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
#[doc = " Or, the badge or guard value is invalid."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst The source capability cannot be derived  @xmlonly <docref>(see <autoref label=\"sec:cap_derivation\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Mint(
    _service: seL4_CNode,
    dest_index: seL4_Word,
    dest_depth: seL4_Uint8,
    src_root: seL4_CNode,
    src_index: seL4_Word,
    src_depth: seL4_Uint8,
    rights: seL4_CapRights_t,
    badge: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Move\" label=\"cnode_move\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Move a capability @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
#[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
#[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source slot is empty."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Move(
    _service: seL4_CNode,
    dest_index: seL4_Word,
    dest_depth: seL4_Uint8,
    src_root: seL4_CNode,
    src_index: seL4_Word,
    src_depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Mutate\" label=\"cnode_mutate\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Move a capability, setting its guard in the process. This"]
#[doc = " operation is mostly useful for setting the guard of a CNode"]
#[doc = " capability without losing revokability of that CNode capability."]
#[doc = " All other uses can be replaced by a combination of Mint and"]
#[doc = " Delete. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] dest_index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] dest_depth Number of bits of dest_index to resolve to find the destination slot."]
#[doc = " @param[in] src_root CPTR to the CNode that forms the root of the source CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] src_index CPTR to the source slot. Resolved from the root of the source CSpace."]
#[doc = " @param[in] src_depth Number of bits of src_index to resolve to find the source slot."]
#[doc = " @param[in] badge Guard to be applied to the new capability."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The index or depth of the source or destination is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source slot is empty."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the guard value is invalid."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly  or  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Mutate(
    _service: seL4_CNode,
    dest_index: seL4_Word,
    dest_depth: seL4_Uint8,
    src_root: seL4_CNode,
    src_index: seL4_Word,
    src_depth: seL4_Uint8,
    badge: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Rotate\" label=\"cnode_rotate\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Given 3 capability slots - a destination, pivot and source - move the capability in the"]
#[doc = " pivot slot to the destination slot and the capability in the source slot to the pivot slot @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:cnode-ops\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service CPTR to the CNode at the root of the CSpace where the destination slot will be found. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] dest_index CPTR to the destination slot. Resolved relative to _service. Must be empty unless it refers to the same slot as the source slot."]
#[doc = " @param[in] dest_depth Depth to resolve dest_index to."]
#[doc = " @param[in] dest_badge The new capdata for the capability that ends up in the destination slot."]
#[doc = " @param[in] pivot_root CPTR to the CNode at the root of the CSpace where the pivot slot will be found. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] pivot_index CPTR to the pivot slot. Resolved relative to pivot_root. The resolved slot must not refer to the source or destination slots."]
#[doc = " @param[in] pivot_depth Depth to resolve pivot_index to."]
#[doc = " @param[in] pivot_badge The new capdata for the capability that ends up in the pivot slot."]
#[doc = " @param[in] src_root CPTR to the CNode at the root of the CSpace where the source slot will be found. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] src_index CPTR to the source slot. Resolved relative to src_root."]
#[doc = " @param[in] src_depth Depth to resolve src_index to."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst If the destination is not the same slot as the source and the destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The index or depth of the source, destination, or pivot is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"src_root\"/> @endxmlonly  or  @xmlonly <texttt text=\"pivot_root\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the source or pivot slot is empty."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the pivot is the same slot as the source or destination."]
#[doc = " Or, the guard value on the destination or pivot is invalid."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"dest_depth\"/> @endxmlonly ,  @xmlonly <texttt text=\"src_depth\"/> @endxmlonly , or  @xmlonly <texttt text=\"pivot_depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_CNode_Rotate(
    _service: seL4_CNode,
    dest_index: seL4_Word,
    dest_depth: seL4_Uint8,
    dest_badge: seL4_Word,
    pivot_root: seL4_CNode,
    pivot_index: seL4_Word,
    pivot_depth: seL4_Uint8,
    pivot_badge: seL4_Word,
    src_root: seL4_CNode,
    src_index: seL4_Word,
    src_depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Get\" label=\"irq_controlget\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Create an IRQ handler capability @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service An IRQControl capability. This gives you the authority to make this call."]
#[doc = " @param[in] irq The IRQ that you want this capability to handle."]
#[doc = " @param[in] root CPTR to the CNode that forms the root of the destination CSpace. Must be at a depth equivalent to the wordsize."]
#[doc = " @param[in] index CPTR to the destination slot. Resolved from the root of the destination CSpace."]
#[doc = " @param[in] depth Number of bits of dest_index to resolve to find the destination slot."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_DeleteFirst The destination slot contains a capability."]
#[doc = " @retval seL4_FailedLookup The  @xmlonly <texttt text=\"root\"/> @endxmlonly ,  @xmlonly <texttt text=\"index\"/> @endxmlonly , or  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, on x86, an IOAPIC is being used."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"irq\"/> @endxmlonly  is invalid for the target architecture."]
#[doc = " Or, on x86,  @xmlonly <texttt text=\"irq\"/> @endxmlonly  is not in the ISA IRQ range."]
#[doc = " Or,  @xmlonly <texttt text=\"depth\"/> @endxmlonly  is invalid  @xmlonly <docref>(see <autoref label=\"s:cspace-addressing\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_RevokeFirst An IRQ handler capability for  @xmlonly <texttt text=\"irq\"/> @endxmlonly  has already been created."]
pub unsafe extern "C" fn seL4_IRQControl_Get(
    _service: seL4_IRQControl,
    irq: seL4_Word,
    root: seL4_CNode,
    index: seL4_Word,
    depth: seL4_Uint8,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Acknowledge\" label=\"irq_handleracknowledge\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Acknowledge the receipt of an interrupt and re-enable it @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service The IRQ handler capability."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_IRQHandler_Ack(_service: seL4_IRQHandler) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set Notification\" label=\"irq_handlersetnotification\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set the notification which the kernel will signal on interrupts"]
#[doc = " controlled by the supplied IRQ handler capability @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service The IRQ handler capability."]
#[doc = " @param[in] notification The notification which the IRQs will signal."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"notification\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"notification\"/> @endxmlonly  does not have the Write right  @xmlonly <docref>(see <autoref label=\"sec:cap_rights\"/>)</docref> @endxmlonly ."]
pub unsafe extern "C" fn seL4_IRQHandler_SetNotification(
    _service: seL4_IRQHandler,
    notification: seL4_CPtr,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Clear\" label=\"irq_handlerclear\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Clear the handler capability from the IRQ slot @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:interrupts\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service The IRQ handler capability."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_IRQHandler_Clear(_service: seL4_IRQHandler) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Set\" label=\"domainset_set\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Change the domain of a thread. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " <docref>See <autoref label=\"sec:domains\"/>.</docref>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service Capability allowing domain configuration."]
#[doc = " @param[in] domain The thread's new domain."]
#[doc = " @param[in] thread Capability to the TCB which is being operated on."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidArgument The  @xmlonly <texttt text=\"domain\"/> @endxmlonly  is greater than  @xmlonly <texttt text=\"CONFIG_NUM_DOMAINS\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"thread\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_DomainSet_Set(
    _service: seL4_DomainSet,
    domain: seL4_Uint8,
    thread: seL4_TCB,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"ConfigureFlags\" label=\"schedcontrol_configureflags\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Set the parameters of a scheduling context by invoking the scheduling control capability. If the scheduling context is bound to a currently running thread, the parameters will take effect immediately: that is the current budget will be increased or reduced by the difference between the new and previous budget and the replenishment time will be updated according to any difference in the period. This can result in active threads being post-poned or released depending on the nature of the parameter change and the state of the thread. Additionally, if the scheduling context was previously empty (no budget) but bound to a runnable thread, this can result in a thread running for the first time since it now has access to CPU time. This call will return seL4 Invalid Argument if the parameters are too small (smaller than the kernel WCET for this platform) or too large (will overflow the timer). @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " See <autoref label=\"sec:threads\"/>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @param[in] schedcontext Capability to the scheduling context which is being operated on."]
#[doc = " @param[in] budget Timeslice in microseconds, when the budget expires the thread will be pre-empted."]
#[doc = " @param[in] period Period in microseconds, if equal to budget, this thread will be treated as a round-robin thread. Otherwise, sporadic servers will be used to assure the scheduling context does not exceed the budget over the specified period."]
#[doc = " @param[in] extra_refills Number of extra sporadic replenishments this scheduling context should use. Ignored for round-robin threads."]
#[doc = " @param[in] badge Identifier for this scheduling context. Delivered to timeout exception handler. Can be used to determine which scheduling context triggered the timeout."]
#[doc = " @param[in] flags Bitwise OR'd set of seL4_SchedContextFlag."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"schedcontext\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_RangeError The  @xmlonly <texttt text=\"budget\"/> @endxmlonly  or  @xmlonly <texttt text=\"period\"/> @endxmlonly  or  @xmlonly <texttt text=\"extra_refills\"/> @endxmlonly  is too big or too small."]
#[doc = " Or,  @xmlonly <texttt text=\"budget\"/> @endxmlonly  is greater than  @xmlonly <texttt text=\"period\"/> @endxmlonly ."]
pub unsafe extern "C" fn seL4_SchedControl_ConfigureFlags(
    _service: seL4_SchedControl,
    schedcontext: seL4_SchedContext,
    budget: seL4_Time,
    period: seL4_Time,
    extra_refills: seL4_Word,
    badge: seL4_Word,
    flags: seL4_Word,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Bind\" label=\"schedcontext_bind\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Bind an object to a scheduling context. The object can be a notification object or a"]
#[doc = " thread."]
#[doc = ""]
#[doc = " If the object is a thread and the thread is in a runnable state and the scheduling"]
#[doc = " context has available budget, this will start the thread running."]
#[doc = ""]
#[doc = " If the object is a notification, when passive threads wait on the notification object and"]
#[doc = " a signal arrives, the passive thread will receive the scheduling context and possess it"]
#[doc = " until it waits on the notification object again."]
#[doc = ""]
#[doc = " This operation will fail for notification objects if the scheduling context is already"]
#[doc = " bound to a notification object, and for thread objects if the the scheduling context is"]
#[doc = " already bound to a thread. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " See <autoref label=\"sec:threads\"/>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @param[in] cap Capability to a TCB or a notification object"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"cap\"/> @endxmlonly  is already bound to the same type of object."]
#[doc = " Or,  @xmlonly <texttt text=\"cap\"/> @endxmlonly  is a TCB in the blocked state and  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not schedulable."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"cap\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_SchedContext_Bind(_service: seL4_SchedContext, cap: seL4_CPtr) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Unbind\" label=\"schedcontext_unbind\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Unbind any objects (threads or notification objects) from a scheduling context. This"]
#[doc = " will render the bound thread passive, see Section 6.1.5. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " See <autoref label=\"sec:threads\"/>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or, the current thread's TCB is bound to  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_SchedContext_Unbind(_service: seL4_SchedContext) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"UnbindObject\" label=\"schedcontext_unbindobject\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Unbind an object from a scheduling context. The object can be either a thread or a"]
#[doc = " notification."]
#[doc = ""]
#[doc = " If the thread being unbound is the thread that is bound to this scheduling context,"]
#[doc = " this will render the thread passive. However if the thread being"]
#[doc = " unbound received the scheduling context via scheduling context donation over IPC,"]
#[doc = " the scheduling context will be returned to the thread that it was originally bound to."]
#[doc = ""]
#[doc = " If the object is a notification and it is bound to the scheduling context, unbind it. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " See <autoref label=\"sec:passive\"/>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @param[in] cap Capability to a notification that is bound to the scheduling context or capability to a tcb that is bound to this scheduling context or has received it through scheduling context donation."]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"cap\"/> @endxmlonly  is not bound to  @xmlonly <texttt text=\"_service\"/> @endxmlonly ."]
#[doc = " Or,  @xmlonly <texttt text=\"cap\"/> @endxmlonly  is the current thread's TCB."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  or  @xmlonly <texttt text=\"cap\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_SchedContext_UnbindObject(
    _service: seL4_SchedContext,
    cap: seL4_CPtr,
) -> seL4_Error{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"Consumed\" label=\"schedcontext_consumed\"/> @endxmlonly"]
#[doc = " @brief @xmlonly Return the amount of time used by this scheduling context since this function was last called or a timeout exception triggered. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " See <autoref label=\"sec:threads\"/>"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @return @xmlonly <errorenumdesc/> @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_SchedContext_Consumed(_service: seL4_SchedContext) -> seL4_SchedContext_Consumed_t{
    unimplemented!()
}
#[doc = " @xmlonly <manual name=\"YieldTo\" label=\"schedcontext_yieldto\"/> @endxmlonly"]
#[doc = " @brief @xmlonly If a thread is currently runnable and running on this scheduling context and the scheduling context has available budget, place it at the head of the scheduling queue."]
#[doc = " If the caller is at an equal priority to the thread this will result in the thread being scheduled."]
#[doc = " If the caller is at a higher priority the thread will not run until the threads priority is the highest priority in the system."]
#[doc = " The caller must have a maximum control priority greater than or equal to the threads priority. @endxmlonly"]
#[doc = ""]
#[doc = " @xmlonly"]
#[doc = " TODO"]
#[doc = " @endxmlonly"]
#[doc = ""]
#[doc = " @param[in] _service"]
#[doc = " @return @xmlonly @endxmlonly"]
#[doc = " @retval seL4_IllegalOperation The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
#[doc = " Or,  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is not bound to a TCB or is bound to the current thread's TCB."]
#[doc = " Or, the target thread's priority is greater than the current thread's maximum controlled priority  @xmlonly <docref>(see <autoref label=\"sec:sched\"/>)</docref> @endxmlonly ."]
#[doc = " @retval seL4_InvalidCapability The  @xmlonly <texttt text=\"_service\"/> @endxmlonly  is a CPtr to a capability of the wrong type."]
pub unsafe extern "C" fn seL4_SchedContext_YieldTo(_service: seL4_SchedContext) -> seL4_SchedContext_YieldTo_t{
    unimplemented!()
}
pub const seL4_CapNull: _bindgen_ty_2 = 0;
pub const seL4_CapInitThreadTCB: _bindgen_ty_2 = 1;
pub const seL4_CapInitThreadCNode: _bindgen_ty_2 = 2;
pub const seL4_CapInitThreadVSpace: _bindgen_ty_2 = 3;
pub const seL4_CapIRQControl: _bindgen_ty_2 = 4;
pub const seL4_CapASIDControl: _bindgen_ty_2 = 5;
pub const seL4_CapInitThreadASIDPool: _bindgen_ty_2 = 6;
pub const seL4_CapIOPortControl: _bindgen_ty_2 = 7;
pub const seL4_CapIOSpace: _bindgen_ty_2 = 8;
pub const seL4_CapBootInfoFrame: _bindgen_ty_2 = 9;
pub const seL4_CapInitThreadIPCBuffer: _bindgen_ty_2 = 10;
pub const seL4_CapDomain: _bindgen_ty_2 = 11;
pub const seL4_CapSMMUSIDControl: _bindgen_ty_2 = 12;
pub const seL4_CapSMMUCBControl: _bindgen_ty_2 = 13;
pub const seL4_CapInitThreadSC: _bindgen_ty_2 = 14;
pub const seL4_NumInitialCaps: _bindgen_ty_2 = 15;
pub type _bindgen_ty_2 = u32;
pub type seL4_SlotPos = seL4_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_SlotRegion {
    pub start: seL4_SlotPos,
    pub end: seL4_SlotPos,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_UntypedDesc {
    pub paddr: seL4_Word,
    pub sizeBits: seL4_Uint8,
    pub isDevice: seL4_Uint8,
    pub padding: [seL4_Uint8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seL4_BootInfo {
    pub extraLen: seL4_Word,
    pub nodeID: seL4_NodeId,
    pub numNodes: seL4_Word,
    pub numIOPTLevels: seL4_Word,
    pub ipcBuffer: *mut seL4_IPCBuffer,
    pub empty: seL4_SlotRegion,
    pub sharedFrames: seL4_SlotRegion,
    pub userImageFrames: seL4_SlotRegion,
    pub userImagePaging: seL4_SlotRegion,
    pub ioSpaceCaps: seL4_SlotRegion,
    pub extraBIPages: seL4_SlotRegion,
    pub initThreadCNodeSizeBits: seL4_Word,
    pub initThreadDomain: seL4_Domain,
    pub schedcontrol: seL4_SlotRegion,
    pub untyped: seL4_SlotRegion,
    pub untypedList: [seL4_UntypedDesc; 230usize],
}
pub const SEL4_BOOTINFO_HEADER_PADDING: seL4_BootInfoID = 0;
pub const SEL4_BOOTINFO_HEADER_X86_VBE: seL4_BootInfoID = 1;
pub const SEL4_BOOTINFO_HEADER_X86_MBMMAP: seL4_BootInfoID = 2;
pub const SEL4_BOOTINFO_HEADER_X86_ACPI_RSDP: seL4_BootInfoID = 3;
pub const SEL4_BOOTINFO_HEADER_X86_FRAMEBUFFER: seL4_BootInfoID = 4;
pub const SEL4_BOOTINFO_HEADER_X86_TSC_FREQ: seL4_BootInfoID = 5;
pub const SEL4_BOOTINFO_HEADER_FDT: seL4_BootInfoID = 6;
pub const SEL4_BOOTINFO_HEADER_MBI2: seL4_BootInfoID = 7;
pub const SEL4_BOOTINFO_HEADER_NUM: seL4_BootInfoID = 8;
pub const _enum_pad_seL4_BootInfoID: seL4_BootInfoID = 9223372036854775807;
pub type seL4_BootInfoID = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_BootInfoHeader {
    pub id: seL4_Word,
    pub len: seL4_Word,
}
pub unsafe extern "C" fn seL4_InitBootInfo(bi: *mut seL4_BootInfo){
    unimplemented!()
}
pub unsafe extern "C" fn seL4_GetBootInfo() -> *mut seL4_BootInfo{
    unimplemented!()
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct seL4_VBEInfoBlock {
    pub signature: [c_types::c_char; 4usize],
    pub version: seL4_Uint16,
    pub oemStringPtr: seL4_Uint32,
    pub capabilities: seL4_Uint32,
    pub modeListPtr: seL4_Uint32,
    pub totalMemory: seL4_Uint16,
    pub oemSoftwareRev: seL4_Uint16,
    pub oemVendorNamePtr: seL4_Uint32,
    pub oemProductNamePtr: seL4_Uint32,
    pub oemProductRevPtr: seL4_Uint32,
    pub reserved: [seL4_Uint8; 222usize],
    pub oemData: [seL4_Uint8; 256usize],
}

pub type seL4_VBEInfoBlock_t = seL4_VBEInfoBlock;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_VBEModeInfoCommon {
    pub modeAttr: seL4_Uint16,
    pub winAAttr: seL4_Uint8,
    pub winBAttr: seL4_Uint8,
    pub winGranularity: seL4_Uint16,
    pub winSize: seL4_Uint16,
    pub winASeg: seL4_Uint16,
    pub winBSeg: seL4_Uint16,
    pub winFuncPtr: seL4_Uint32,
    pub bytesPerScanLine: seL4_Uint16,
}

pub type seL4_VBEModeInfoCommon_t = seL4_VBEModeInfoCommon;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_VBEInfo12Part1 {
    pub xRes: seL4_Uint16,
    pub yRes: seL4_Uint16,
    pub xCharSize: seL4_Uint8,
    pub yCharSize: seL4_Uint8,
    pub planes: seL4_Uint8,
    pub bitsPerPixel: seL4_Uint8,
    pub banks: seL4_Uint8,
    pub memoryModel: seL4_Uint8,
    pub bankSize: seL4_Uint8,
    pub imagePages: seL4_Uint8,
    pub reserved1: seL4_Uint8,
}

pub type seL4_VBEInfo12Part1_t = seL4_VBEInfo12Part1;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_VBEInfo12Part2 {
    pub redLen: seL4_Uint8,
    pub redOff: seL4_Uint8,
    pub greenLen: seL4_Uint8,
    pub greenOff: seL4_Uint8,
    pub blueLen: seL4_Uint8,
    pub blueOff: seL4_Uint8,
    pub rsvdLen: seL4_Uint8,
    pub rsvdOff: seL4_Uint8,
    pub directColorInfo: seL4_Uint8,
}

pub type seL4_VBEInfo12Part2_t = seL4_VBEInfo12Part2;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_VBEInfo20 {
    pub physBasePtr: seL4_Uint32,
    pub reserved2: [seL4_Uint8; 6usize],
}

pub type seL4_VBEInfo20_t = seL4_VBEInfo20;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_VBEInfo30 {
    pub linBytesPerScanLine: seL4_Uint16,
    pub bnkImagePages: seL4_Uint8,
    pub linImagePages: seL4_Uint8,
    pub linRedLen: seL4_Uint8,
    pub linRedOff: seL4_Uint8,
    pub linGreenLen: seL4_Uint8,
    pub linGreenOff: seL4_Uint8,
    pub linBlueLen: seL4_Uint8,
    pub linBlueOff: seL4_Uint8,
    pub linRsvdLen: seL4_Uint8,
    pub linRsvdOff: seL4_Uint8,
    pub maxPixelClock: seL4_Uint32,
    pub modeId: seL4_Uint16,
    pub depth: seL4_Uint8,
}

pub type seL4_VBEInfo30_t = seL4_VBEInfo30;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct seL4_VBEModeInfoBlock {
    pub vbe_common: seL4_VBEModeInfoCommon_t,
    pub vbe12_part1: seL4_VBEInfo12Part1_t,
    pub vbe12_part2: seL4_VBEInfo12Part2_t,
    pub vbe20: seL4_VBEInfo20_t,
    pub vbe30: seL4_VBEInfo30_t,
    pub reserved3: [seL4_Uint8; 187usize],
}

pub type seL4_VBEModeInfoBlock_t = seL4_VBEModeInfoBlock;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _seL4_X86_BootInfo_VBE {
    pub header: seL4_BootInfoHeader,
    pub vbeInfoBlock: seL4_VBEInfoBlock_t,
    pub vbeModeInfoBlock: seL4_VBEModeInfoBlock_t,
    pub vbeMode: seL4_Uint32,
    pub vbeInterfaceSeg: seL4_Uint32,
    pub vbeInterfaceOff: seL4_Uint32,
    pub vbeInterfaceLen: seL4_Uint32,
}

pub type seL4_X86_BootInfo_VBE = _seL4_X86_BootInfo_VBE;
#[doc = " Copy of multiboot mmap fields."]
#[doc = " https://www.gnu.org/software/grub/manual/multiboot/multiboot.html"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_X86_mb_mmap {
    pub size: seL4_Uint32,
    pub base_addr: seL4_Uint64,
    pub length: seL4_Uint64,
    pub type_: seL4_Uint32,
}

#[doc = " Copy of multiboot mmap fields."]
#[doc = " https://www.gnu.org/software/grub/manual/multiboot/multiboot.html"]
pub type seL4_X86_mb_mmap_t = seL4_X86_mb_mmap;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct seL4_X86_BootInfo_mmap {
    pub header: seL4_BootInfoHeader,
    pub mmap_length: seL4_Uint32,
    pub mmap: [seL4_X86_mb_mmap_t; 50usize],
}

pub type seL4_X86_BootInfo_mmap_t = seL4_X86_BootInfo_mmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiboot2_fb {
    _unused: [u8; 0],
}
pub type seL4_X86_BootInfo_fb_t = multiboot2_fb;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seL4_BootInfo_mbi2 {
    pub header: seL4_BootInfoHeader,
    pub mbi_vaddr: seL4_Word,
    pub mbi_paddr: seL4_Word,
}

pub type seL4_BootInfo_MBI2 = seL4_BootInfo_mbi2;

pub unsafe extern "C" fn seL4_getArchFault(tag: seL4_MessageInfo_t) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_getFault(tag: seL4_MessageInfo_t) -> seL4_Fault_t{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isDebugException_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isVMFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isUnknownSyscall_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isUserException_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isNullFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isCapFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_isTimeoutFault_tag(tag: seL4_MessageInfo_t) -> seL4_Bool{
    unimplemented!()
}
pub unsafe extern "C" fn seL4_TimeoutReply_new(
    resume: seL4_Bool,
    regs: seL4_UserContext,
    length: seL4_Word,
) -> seL4_MessageInfo_t{
    unimplemented!()
}
pub const _seL4_MsgMaxExtraCaps: c_types::c_ulong = 3;
pub const seL4_MsgMaxExtraCaps: c_types::c_ulong = 3;


